<!DOCTYPE html><html lang=zh><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=renderer content=webkit><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>18K软件 AI工具 免费资源</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/libs/highlight/styles/18k.css><meta name=generator content="Hexo 7.3.0"></head><body id=bodyx><div class="hd posts"><a href=javascript:history.back() class=replay-btn>返回</a><div class=post-title><p>CVE-2025-32756 Fortinet RCE Exploited in the Wild Horizon3.ai</p><hr></div><div class=post-content><h1 id=CVE-2025-32756-Low-Rise-Jeans-are-Back-and-so-are-Buffer-Overflows><a href=#CVE-2025-32756-Low-Rise-Jeans-are-Back-and-so-are-Buffer-Overflows class=headerlink title="CVE-2025-32756: Low-Rise Jeans are Back and so are Buffer Overflows"></a>CVE-2025-32756: Low-Rise Jeans are Back and so are Buffer Overflows</h1><p>Jimi Sebree  |  May 22, 2025  |  <a target=_blank rel=noopener href=https://horizon3.ai/category/attack-research/attack-blogs/ >Attack Blogs</a></p><p>On May 13, 2025, FortiGuard Labs <a target=_blank rel=noopener href=https://fortiguard.fortinet.com/psirt/FG-IR-25-254>published an advisory</a> detailing <a target=_blank rel=noopener href="https://www.cve.org/CVERecord?id=CVE-2025-32756">CVE-2025-32756</a>, which affects a variety of Fortinet products:</p><ul><li>FortiCamera</li><li>FortiMail</li><li>FortiNDR</li><li>FortiRecorder</li><li>FortiVoice</li></ul><p>In their advisory, FortiGuard Labs states that Fortinet has observed this issue being exploited in the wild. The next day, May 14, the vulnerability was added to the <a target=_blank rel=noopener href=https://www.cisa.gov/known-exploited-vulnerabilities-catalog>CISA KEV catalog.</a></p><p>The vulnerability is described in the advisory as a stack-based buffer overflow in the administrative API that can lead to unauthenticated remote code execution. Given that it’s being exploited in the wild, we figured we’d take a closer look. If you’d rather run the test instead of reading this write-up, coverage is already available in NodeZero.</p><h1 id=Looking-for-Clues><a href=#Looking-for-Clues class=headerlink title="Looking for Clues"></a>Looking for Clues</h1><p>For our reversing efforts, we chose to look at a patched and unpatched version of FortiMail. The Indicators of Compromise (IOCs) listed in the advisory give us some hints about where to begin.</p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_3.jpg></p><p><a target=_blank rel=noopener href=https://fortiguard.fortinet.com/psirt/FG-IR-25-254>https://fortiguard.fortinet.com/psirt/FG-IR-25-254</a></p><p>The log output displayed here tells us a couple of important things:</p><ul><li>We’re looking for a way to execute the admin.fe cgi binary</li><li>The web server is using mod_fcgid, which makes our lives a bit easier when attempting to exploit the target, as it’s unlikely that failed attempts will crash the entire httpd process and lock us out of the application.</li></ul><p>From the web server configuration file (httpd.conf), we find our entry point:</p><p><code>ScriptAlias /module/ &quot;/migadmin/www/fcgi/&quot;</code></p><p>A quick curl request validates that we can hit the admin.fe endpoint:</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext"># curl -k -L -v https://REDACTED/module/admin.fe<br><br>&lt; HTTP/1.1 200 OK<br>&lt; Date: Tue, 20 May 2025 23:17:44 GMT<br>&lt; Cache-Control: no-cache<br>&lt; Strict-Transport-Security: max-age=31536000; includeSubDomains<br>&lt; Set-Cookie: APSCOOKIE_ffbe3e4d0e3350075e9c91f574e799cc=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: ParamStr=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: mTime=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: logLevel=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: logType=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: logStartline=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: logDomain=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: totalLineNumber=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: SearchResultFile=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Vary: Accept-Encoding<br>&lt; X-XSS-Protection: 1; mode=block<br>&lt; X-Frame-Options: SAMEORIGIN<br>&lt; X-Content-Type-Options: nosniff<br>&lt; Content-Security-Policy: script-src &#x27;self&#x27;; object-src &#x27;none&#x27;; frame-ancestors &#x27;self&#x27; https://*.fortimailcloud.com/ https://fortimail.forticloud.com/<br>&lt; Transfer-Encoding: chunked<br>&lt; Content-Type: text/plain<br>&lt;<br><br>&#123;&quot;errorType&quot;: 7,&quot;errorMsg&quot;: &quot;Failed: Access denied&quot;,&quot;reqAction&quot;: 0,&quot;totalRemoteCount&quot;: 0,&quot;collection&quot;: &quot;[]&quot;&#125;<br></code></pre></td></tr></table></figure><p>Unfortunately, when attempting to diff admin.fe between patched and unpatched versions… we discovered that the binaries were identical. This means the vulnerability is likely in a shared library, so it’s time to crack things open.</p><h1 id=Getting-Our-Hands-Dirty><a href=#Getting-Our-Hands-Dirty class=headerlink title="Getting Our Hands Dirty"></a>Getting Our Hands Dirty</h1><p><em>Ghidra Imports View</em></p><p>Oh. Gross. A boost library… which likely means C++… Instead of beating our heads against the wall for the next several hours, we asked a ChatGPT for some help via the <a target=_blank rel=noopener href=https://github.com/LaurieWired/GhidraMCP>Ghidra-MCP</a> bridge and Github Copilot.</p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_5.jpg></p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_6.jpg></p><p>After taking a closer look at the function recommended to us, we spot a familiar string: APSCOOKIE. If you refer to our earlier test with curl, you’ll notice that one of the returned cookies was this very value.</p><p>If you play with the admin web interface for a little bit, you’ll start to see the occasional requests to the admin.fe endpoint that contain this APSCOOKIE value, which appears to be used for session management.</p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_7.jpg></p><p>After decoding this cookie value we get:</p><p><code>Era=0&amp;Payload=qCStu1vT3v+Y++5pCCs9M/CxxddCRrC8SHg+9cfRCA42GU7Cf+8p3iBFSl/4vHteSGePZgk7KGMb8kzRR5c2boDUfiiD65jkByiD3DuRCj1NJR7ESpZQIZlOffSxykRbCTp5l3InoU+q6psG+ve+IRDk9za5K0No9T5RNxCwZxM=&amp;AuthHash=kz4cHPsgudYxy4PPp123FUto=&amp;</code></p><p>The APSCOOKIE has the following URL-encoded fields:</p><ul><li>Era</li><li>Payload</li><li>AuthHash</li></ul><p>Those sound like great values to start grepping for.</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">$ grep -rl &quot;Era&quot; ./762 | xargs grep -rl &quot;Payload&quot; | xargs grep -rl &quot;AuthHash&quot;<br>rootfs/lib/libhttputil.so<br><br>$ diff 762/rootfs/lib/libhttputil.so 763/rootfs/lib/libhttputil.so<br>Binary files 762/rootfs/lib/libhttputil.so and 763/rootfs/lib/libhttputil.so differ<br></code></pre></td></tr></table></figure><p>Given that there is only one file with these values and it differs between patched and vulnerable versions of the products, it’s likely we’ve found the culprit.</p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_8.jpg></p><p>After loading up both versions in Ghidra, we can see that these strings are all referenced within the function cookieval_unwrap(). We decided to give our brains a break and see how far our little AI helper can get us.</p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_9.jpg></p><p>Not too bad for a first response. Let’s keep going.</p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_10.jpg></p><p>Unfortunately, responses start becoming less and less reliable after this, so let’s focus on some good old-fashioned manual analysis using ChatGPT’s observations as a starting point.</p><p>Skimming through the function, cookieval_unwrap() appears to be dedicated to performing the base64 decoding of each ASPCOOKIE field and writing it back to the input buffer. Since Era is expected to be a single digit, let’s focus our efforts on Payload and AuthHash. We’ll skim through the decompilations of the patched and unpatched versions of the function to track down references to each of these values.</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">----------<br>Unpatched:<br>----------<br>size_t input_size;<br>size_t __size;<br>uchar *AuthHash;<br>uchar *Payload;<br>long output_buffer [2];<br>out_00 = (uchar *)malloc(__size);<br><br>iVar2 = __isoc99_sscanf(param_1,&quot;Era=%1d&amp;Payload=%m[^&amp;]&amp;AuthHash=%m[^&amp;]&amp;&quot;,&amp;Era,&amp;Payload, &amp;AuthHash);<br><br>input_size = strlen((char *)AuthHash);<br>__size = strlen((char *)Payload);<br><br><br>iVar3 = EVP_DecodeUpdate(ctx,(uchar *)output_buffer,&amp;output_size,AuthHash,(int)input_size);<br><br>iVar2 = EVP_DecodeUpdate(ctx,out_00,&amp;local_94,Payload,iVar2);<br><br><br>----------<br>Patched:<br>----------<br>size_t input_size;<br>size_t __size;<br>uchar *AuthHash;<br>uchar *Payload;<br>long output_buffer [2];<br>out_00 = (uchar *)malloc(__size);<br><br>iVar2 = __isoc99_sscanf(param_1,&quot;Era=%1d&amp;Payload=%m[^&amp;]&amp;AuthHash=%m[^&amp;]&amp;&quot;,&amp;Era,&amp;Payload, &amp;AuthHash);<br><br>input_size = strlen((char *)AuthHash);<br>__size = strlen((char *)Payload);<br><br>input_size = strlen((char *)AuthHash);<br>if (input_size &lt; 0x1e) &#123;<br><br>iVar3 = EVP_DecodeUpdate(ctx,(uchar *)output_buffer,&amp;output_size,AuthHash,(int)input_size);<br><br>iVar2 = EVP_DecodeUpdate(ctx,out_00,&amp;local_94,Payload,iVar2);<br></code></pre></td></tr></table></figure><p>The key difference between the patched and unpatched function appears to be a size check for the size of the user-supplied AuthHash value. In the original version, we can see that AuthHash is decoded and written to the output buffer, which is only big enough to hold 16 bytes. In the patched version, we can see that the added size check limits the amount of data that a user can send in this value. Essentially, we now know that the memcpy() pointed out by ChatGPT isn’t entirely correct, and the real overflow occurs because of a call to EVP_DecodeUpdate() that writes beyond the bounds allocated for the decoded AuthHash value.</p><p>Now we know where the overflow occurs, but how much control does it give us? Let’s take a look at the stack allocation starting with our output buffer:</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">RSP+0x50 : local_78 (16 bytes)        &lt;- Start of overflow<br>RSP+0x60 : local_68 (4 bytes)         &lt;- Overwritten<br>RSP+0x70 : local_58 (16 bytes)        &lt;- Overwritten<br>RSP+0x80 : local_48 (16 bytes)        &lt;- Overwritten<br>RSP+0x90 : saved RBX                  &lt;- Overwritten ---v<br>RSP+0x98 : saved RBP                  &lt;- Overwritten<br>RSP+0xA0 : saved R12                  &lt;- Overwritten   These are saved in the<br>RSP+0xA8 : saved R13                  &lt;- Overwritten   function prologue<br>RSP+0xB0 : saved R14                  &lt;- Overwritten<br>RSP+0xB8 : saved R15                  &lt;- Overwritten ---^<br>RSP+0xC0 : return address (RIP)       &lt;- Overwritten<br></code></pre></td></tr></table></figure><p>As execution continues, these stack values remain untouched until they are used again by the call to memcpy(). The call to memcpy() happens to use values we already control, which might be useful in crafting a working exploit, but isn’t necessary to delve into for now since we already control the value that will be written to RIP in the function epilogue.</p><p>Let’s start sending some garbage data and see what happens! Since AuthHashl needs to be valid base64, let’s send a bunch of NULL characters properly encoded.</p><p><code>AuthHash%3DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%3D%3D</code></p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_11.jpg></p><p>Looks promising. After a bit of trial-and-error with some cyclic payloads, we’re able to determine the following:</p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_13.jpg></p><p>💥 Given how rare and antiquated simple memory corruptions issues like this have become in the modern age, it was a nice change of pace to revisit some good old-fashioned 90s-era hacking techniques.</p></div></div><div class=footer id=footer><p>Copyright © 2025 <a class=flink target=_blank rel=noopener href=http://www.18k.icu>www.18k.icu</a> <label class="el-switch el-switch-green el-switch-sm" style=vertical-align:sub><input type=checkbox name=switch id=update_style> <span class=el-switch-style></span></label></p></div><input type=hidden id=web_style value=black> <input type=hidden id=valine_appid value=CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz> <input type=hidden id=valine_appKey value=FqiyUqbg7McKN2eG0MCewupf><script src=https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js></script><script src=/libs/highlight/highlight.pack.js></script><script src=/js/js.js></script><style>.v *{color:#698fca}.v .vlist .vcard .vhead .vsys{color:#3a3e4a}.v .vlist .vcard .vh .vmeta .vat{color:#638fd5}.v .vlist .vcard .vhead .vnick{color:#6ba1ff}.v a{color:#8696b1}.v .vlist .vcard .vhead .vnick:hover{color:#669bfc}</style><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?eb7eb8199824646269cd262b46a87950",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script></body></html>