<!DOCTYPE html><html lang=zh><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=renderer content=webkit><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>18K软件 AI工具 免费资源</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/libs/highlight/styles/18k.css><meta name=generator content="Hexo 7.3.0"></head><body id=bodyx><div class="hd posts"><a href=javascript:history.back() class=replay-btn>返回</a><div class=post-title><p>CVE-2025-32756 Fortinet RCE 野外利用</p><hr></div><div class=post-content><h1 id=CVE-2025-32756：低腰牛仔裤回来了，缓冲区溢出也回来了><a href=#CVE-2025-32756：低腰牛仔裤回来了，缓冲区溢出也回来了 class=headerlink title=CVE-2025-32756：低腰牛仔裤回来了，缓冲区溢出也回来了></a>CVE-2025-32756：低腰牛仔裤回来了，缓冲区溢出也回来了</h1><p>2025年5月13日，FortiGuard Labs <a target=_blank rel=noopener href=https://fortiguard.fortinet.com/psirt/FG-IR-25-254>发布了一份公告</a>，详细说明了 <a target=_blank rel=noopener href="https://www.cve.org/CVERecord?id=CVE-2025-32756">CVE-2025-32756</a>，该漏洞影响了多种 Fortinet 产品：</p><ul><li>FortiCamera</li><li>FortiMail</li><li>FortiNDR</li><li>FortiRecorder</li><li>FortiVoice</li></ul><p>FortiGuard Labs 在其公告中指出，Fortinet 已经观察到该问题在野外被利用。第二天，即5月14日，该漏洞被添加到 <a target=_blank rel=noopener href=https://www.cisa.gov/known-exploited-vulnerabilities-catalog>CISA KEV 目录</a>中。</p><p>该漏洞在公告中被描述为管理 API 中的一个基于堆栈的缓冲区溢出，可能导致未经身份验证的远程代码执行。鉴于它正在野外被利用，我们决定仔细研究一下。如果您不想阅读这篇分析报告，而是想直接进行测试，那么 NodeZero 中已经提供了相关覆盖。</p><h1 id=寻找线索><a href=#寻找线索 class=headerlink title=寻找线索></a>寻找线索</h1><p>对于我们的逆向工作，我们选择了查看 FortiMail 的已修补和未修补版本。公告中列出的失陷指标（IOC）为我们从哪里开始提供了一些线索。</p><p><img src=http://www.18k.icu/images/20250615_17_qvugsbox/img_3.jpg></p><p><a target=_blank rel=noopener href=https://fortiguard.fortinet.com/psirt/FG-IR-25-254>https://fortiguard.fortinet.com/psirt/FG-IR-25-254</a></p><p>这里显示的日志输出告诉我们几个重要的事情：</p><ul><li>我们正在寻找一种执行 admin.fe cgi 二进制文件的方法</li><li>Web 服务器正在使用 mod_fcgid，这使得我们在尝试利用目标时生活变得更轻松一些，因为失败的尝试不太可能导致整个 httpd 进程崩溃并将我们锁定在应用程序之外。</li></ul><p>从 Web 服务器配置文件 (httpd.conf) 中，我们找到了我们的入口点：</p><p><code>ScriptAlias /module/ &quot;/migadmin/www/fcgi/&quot;</code></p><p>一个快速的 curl 请求验证了我们可以访问 admin.fe 端点：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext"># curl -k -L -v https://REDACTED/module/admin.fe<br><br>&lt; HTTP/1.1 200 OK<br>&lt; Date: Tue, 20 May 2025 23:17:44 GMT<br>&lt; Cache-Control: no-cache<br>&lt; Strict-Transport-Security: max-age=31536000; includeSubDomains<br>&lt; Set-Cookie: APSCOOKIE_ffbe3e4d0e3350075e9c91f574e799cc=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: ParamStr=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: mTime=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: logLevel=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: logType=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: logStartline=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: logDomain=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: totalLineNumber=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: SearchResultFile=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Vary: Accept-Encoding<br>&lt; X-XSS-Protection: 1; mode=block<br>&lt; X-Frame-Options: SAMEORIGIN<br>&lt; X-Content-Type-Options: nosniff<br>&lt; Content-Security-Policy: script-src &#x27;self&#x27;; object-src &#x27;none&#x27;; frame-ancestors &#x27;self&#x27; https://*.fortimailcloud.com/ https://fortimail.forticloud.com/<br>&lt; Transfer-Encoding: chunked<br>&lt; Content-Type: text/plain<br>&lt;<br><br>&#123;&quot;errorType&quot;: 7,&quot;errorMsg&quot;: &quot;Failed: Access denied&quot;,&quot;reqAction&quot;: 0,&quot;totalRemoteCount&quot;: 0,&quot;collection&quot;: &quot;[]&quot;&#125;<br></code></pre></td></tr></table></figure><p>不幸的是，当尝试在已修补和未修补版本之间对 admin.fe 进行 diff 时……我们发现二进制文件是相同的。这意味着漏洞可能存在于一个共享库中，所以是时候深入挖掘了。</p><h1 id=动手实践><a href=#动手实践 class=headerlink title=动手实践></a>动手实践</h1><p><img src=http://www.18k.icu/images/20250615_17_qvugsbox/img_4.jpg></p><p><em>Ghidra 导入视图</em></p><p>哦。恶心。一个 boost 库……这很可能意味着是 C++……为了不在接下来的几个小时里碰壁，我们通过 <a target=_blank rel=noopener href=https://github.com/LaurieWired/GhidraMCP>Ghidra-MCP</a> 桥和 Github Copilot 向 ChatGPT 寻求了一些帮助。</p><p><img src=http://www.18k.icu/images/20250615_17_qvugsbox/img_5.jpg></p><p><img src=http://www.18k.icu/images/20250615_17_qvugsbox/img_6.jpg></p><p>在仔细查看了向我们推荐的函数后，我们发现了一个熟悉的字符串：APSCOOKIE。如果您回顾一下我们之前用 curl 进行的测试，您会注意到返回的 cookie 中有一个正是这个值。</p><p>如果您在管理 Web 界面上玩一会儿，您会开始看到偶尔会有包含此 APSCOOKIE 值的对 admin.fe 端点的请求，该值似乎用于会话管理。</p><p><img src=http://www.18k.icu/images/20250615_17_qvugsbox/img_7.jpg></p><p>解码此 cookie 值后，我们得到：</p><p><code>Era=0&amp;Payload=qCStu1vT3v+Y++5pCCs9M/CxxddCRrC8SHg+9cfRCA42GU7Cf+8p3iBFSl/4vHteSGePZgk7KGMb8kzRR5c2boDUfiiD65jkByiD3DuRCj1NJR7ESpZQIZlOffSxykRbCTp5l3InoU+q6psG+ve+IRDk9za5K0No9T5RNxCwZxM=&amp;AuthHash=kz4cHPsgudYxy4PPp123FUto=&amp;</code></p><p>APSCOOKIE 具有以下 URL 编码的字段：</p><ul><li>Era</li><li>Payload</li><li>AuthHash</li></ul><p>这些听起来是开始进行 grep 的好值。</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">$ grep -rl &quot;Era&quot; ./762 | xargs grep -rl &quot;Payload&quot; | xargs grep -rl &quot;AuthHash&quot;<br>rootfs/lib/libhttputil.so<br><br>$ diff 762/rootfs/lib/libhttputil.so 763/rootfs/lib/libhttputil.so<br>Binary files 762/rootfs/lib/libhttputil.so and 763/rootfs/lib/libhttputil.so differ<br></code></pre></td></tr></table></figure><p>鉴于只有一个文件包含这些值，并且它在产品的已修补和易受攻击版本之间有所不同，我们很可能已经找到了罪魁祸首。</p><p><img src=http://www.18k.icu/images/20250615_17_qvugsbox/img_8.jpg></p><p>在 Ghidra 中加载两个版本后，我们可以看到这些字符串都在函数 cookieval_unwrap() 中被引用。我们决定让大脑休息一下，看看我们的小 AI 助手能帮我们走多远。</p><p><img src=http://www.18k.icu/images/20250615_17_qvugsbox/img_9.jpg></p><p>对于第一次响应来说还不错。我们继续。</p><p><img src=http://www.18k.icu/images/20250615_17_qvugsbox/img_10.jpg></p><p>不幸的是，在此之后响应开始变得越来越不可靠，所以让我们以 ChatGPT 的观察为起点，专注于一些传统的手动分析。</p><p>粗略地浏览函数，cookieval_unwrap() 似乎专门用于执行每个 ASPCOOKIE 字段的 base64 解码并将其写回输入缓冲区。由于 Era 预计是一个单位数，让我们将精力集中在 Payload 和 AuthHash 上。我们将浏览该函数的已修补和未修补版本的反编译代码，以追踪对这些值的引用。</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">----------<br>未修补：<br>----------<br>size_t input_size;<br>size_t __size;<br>uchar *AuthHash;<br>uchar *Payload;<br>long output_buffer [2];<br>out_00 = (uchar *)malloc(__size);<br><br>iVar2 = __isoc99_sscanf(param_1,&quot;Era=%1d&amp;Payload=%m[^&amp;]&amp;AuthHash=%m[^&amp;]&amp;&quot;,&amp;Era,&amp;Payload, &amp;AuthHash);<br><br>input_size = strlen((char *)AuthHash);<br>__size = strlen((char *)Payload);<br><br><br>iVar3 = EVP_DecodeUpdate(ctx,(uchar *)output_buffer,&amp;output_size,AuthHash,(int)input_size);<br><br>iVar2 = EVP_DecodeUpdate(ctx,out_00,&amp;local_94,Payload,iVar2);<br><br><br>----------<br>已修补：<br>----------<br>size_t input_size;<br>size_t __size;<br>uchar *AuthHash;<br>uchar *Payload;<br>long output_buffer [2];<br>out_00 = (uchar *)malloc(__size);<br><br>iVar2 = __isoc99_sscanf(param_1,&quot;Era=%1d&amp;Payload=%m[^&amp;]&amp;AuthHash=%m[^&amp;]&amp;&quot;,&amp;Era,&amp;Payload, &amp;AuthHash);<br><br>input_size = strlen((char *)AuthHash);<br>__size = strlen((char *)Payload);<br><br>input_size = strlen((char *)AuthHash);<br>if (input_size &lt; 0x1e) &#123;<br><br>iVar3 = EVP_DecodeUpdate(ctx,(uchar *)output_buffer,&amp;output_size,AuthHash,(int)input_size);<br><br>iVar2 = EVP_DecodeUpdate(ctx,out_00,&amp;local_94,Payload,iVar2);<br></code></pre></td></tr></table></figure><p>已修补和未修补函数之间的关键区别似乎是对用户提供的 AuthHash 值大小的大小检查。在原始版本中，我们可以看到 AuthHash 被解码并写入输出缓冲区，而该缓冲区只够容纳 16 个字节。在已修补版本中，我们可以看到添加的大小检查限制了用户可以在此值中发送的数据量。基本上，我们现在知道 ChatGPT 指出的 memcpy() 并不完全正确，真正的溢出是由于调用 EVP_DecodeUpdate()，它写入了为解码的 AuthHash 值分配的边界之外。</p><p>现在我们知道溢出发生在哪里，但它给了我们多少控制权呢？让我们从输出缓冲区开始看一下堆栈分配：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">RSP+0x50 : local_78 (16 字节)        &lt;- 溢出开始<br>RSP+0x60 : local_68 (4 字节)         &lt;- 被覆盖<br>RSP+0x70 : local_58 (16 字节)        &lt;- 被覆盖<br>RSP+0x80 : local_48 (16 字节)        &lt;- 被覆盖<br>RSP+0x90 : 已保存的 RBX                  &lt;- 被覆盖 ---v<br>RSP+0x98 : 已保存的 RBP                  &lt;- 被覆盖<br>RSP+0xA0 : 已保存的 R12                  &lt;- 被覆盖   这些在函数序言中保存<br>RSP+0xA8 : 已保存的 R13                  &lt;- 被覆盖<br>RSP+0xB0 : 已保存的 R14                  &lt;- 被覆盖<br>RSP+0xB8 : 已保存的 R15                  &lt;- 被覆盖 ---^<br>RSP+0xC0 : 返回地址 (RIP)       &lt;- 被覆盖<br></code></pre></td></tr></table></figure><p>随着执行的继续，这些堆栈值保持不变，直到它们再次被 memcpy() 调用使用。memcpy() 的调用恰好使用了我们已经控制的值，这可能对制作一个有效的漏洞利用很有用，但现在没有必要深入研究，因为我们已经控制了将在函数尾声中写入 RIP 的值。</p><p>让我们开始发送一些垃圾数据，看看会发生什么！由于 AuthHashl 需要是有效的 base64，让我们发送一堆正确编码的 NULL 字符。</p><p><code>AuthHash%3DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%3D%3D</code></p><p><img src=http://www.18k.icu/images/20250615_17_qvugsbox/img_11.jpg></p><p>看起来很有希望。经过一些循环有效载荷的反复试验后，我们能够确定以下内容：</p><p><img src=http://www.18k.icu/images/20250615_17_qvugsbox/img_12.jpg></p><p><img src=http://www.18k.icu/images/20250615_17_qvugsbox/img_13.jpg></p><p>💥 鉴于像这样的简单内存损坏问题在现代已经变得多么罕见和过时，重温一些上世纪 90 年代的老式黑客技术是一种不错的改变。</p></div></div><div class=footer id=footer><p>Copyright © 2025 <a class=flink target=_blank rel=noopener href=http://www.18k.icu>www.18k.icu</a> <label class="el-switch el-switch-green el-switch-sm" style=vertical-align:sub><input type=checkbox name=switch id=update_style> <span class=el-switch-style></span></label></p></div><input type=hidden id=web_style value=black> <input type=hidden id=valine_appid value=CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz> <input type=hidden id=valine_appKey value=FqiyUqbg7McKN2eG0MCewupf><script src=https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js></script><script src=/libs/highlight/highlight.pack.js></script><script src=/js/js.js></script><style>.v *{color:#698fca}.v .vlist .vcard .vhead .vsys{color:#3a3e4a}.v .vlist .vcard .vh .vmeta .vat{color:#638fd5}.v .vlist .vcard .vhead .vnick{color:#6ba1ff}.v a{color:#8696b1}.v .vlist .vcard .vhead .vnick:hover{color:#669bfc}</style><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?eb7eb8199824646269cd262b46a87950",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script></body></html>