<!DOCTYPE html><html lang=zh><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=renderer content=webkit><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>18K软件 AI工具 免费资源</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/libs/highlight/styles/18k.css><meta name=generator content="Hexo 7.3.0"></head><body id=bodyx><div class="hd posts"><a href=javascript:history.back() class=replay-btn>返回</a><div class=post-title><p>CVE-2025-32756 Fortinet RCE 在野外被利用</p><hr></div><div class=post-content><h1 id=CVE-2025-32756：低腰牛仔裤又回来了，缓冲区溢出也一样><a href=#CVE-2025-32756：低腰牛仔裤又回来了，缓冲区溢出也一样 class=headerlink title=CVE-2025-32756：低腰牛仔裤又回来了，缓冲区溢出也一样></a>CVE-2025-32756：低腰牛仔裤又回来了，缓冲区溢出也一样</h1><p>Jimi Sebree  |  2025年5月22日  |  <a target=_blank rel=noopener href=https://horizon3.ai/category/attack-research/attack-blogs/ >攻击博客</a></p><p>2025年5月13日，FortiGuard实验室<a target=_blank rel=noopener href=https://fortiguard.fortinet.com/psirt/FG-IR-25-254>发布了一份公告</a>，详细介绍了影响多种Fortinet产品的<a target=_blank rel=noopener href="https://www.cve.org/CVERecord?id=CVE-2025-32756">CVE-2025-32756</a>：</p><ul><li>FortiCamera</li><li>FortiMail</li><li>FortiNDR</li><li>FortiRecorder</li><li>FortiVoice</li></ul><p>在他们的公告中，FortiGuard实验室表示Fortinet已观察到此问题在野外被利用。第二天，5月14日，该漏洞被添加到<a target=_blank rel=noopener href=https://www.cisa.gov/known-exploited-vulnerabilities-catalog>CISA KEV目录</a>。</p><p>该漏洞在公告中被描述为管理API中的基于栈的缓冲区溢出，可能导致未经身份验证的远程代码执行。鉴于它正在野外被利用，我们决定仔细研究一下。如果您更愿意运行测试而不是阅读本报告，NodeZero已经提供了相关覆盖。</p><h1 id=寻找线索><a href=#寻找线索 class=headerlink title=寻找线索></a>寻找线索</h1><p>为了进行逆向工程，我们选择了分析FortiMail的补丁版本和未补丁版本。公告中列出的威胁指标（IOCs）为我们提供了一些关于从哪里开始的提示。</p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_3.jpg></p><p><a target=_blank rel=noopener href=https://fortiguard.fortinet.com/psirt/FG-IR-25-254>https://fortiguard.fortinet.com/psirt/FG-IR-25-254</a></p><p>此处显示的日志输出告诉我们几件重要的事情：</p><ul><li>我们正在寻找一种方法来执行admin.fe cgi二进制文件</li><li>网络服务器使用mod_fcgid，这在尝试利用目标时让我们的生活变得轻松一些，因为失败的尝试不太可能导致整个httpd进程崩溃并将我们锁在应用程序之外。</li></ul><p>从web服务器配置文件（httpd.conf）中，我们找到了入口点：</p><p><code>ScriptAlias /module/ &quot;/migadmin/www/fcgi/&quot;</code></p><p>一个快速的curl请求验证了我们可以访问admin.fe端点：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext"># curl -k -L -v https://REDACTED/module/admin.fe<br><br>&lt; HTTP/1.1 200 OK<br>&lt; Date: Tue, 20 May 2025 23:17:44 GMT<br>&lt; Cache-Control: no-cache<br>&lt; Strict-Transport-Security: max-age=31536000; includeSubDomains<br>&lt; Set-Cookie: APSCOOKIE_ffbe3e4d0e3350075e9c91f574e799cc=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: ParamStr=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: mTime=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: logLevel=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: logType=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: logStartline=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: logDomain=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: totalLineNumber=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Set-Cookie: SearchResultFile=; Expires=Fri, 01-Jan-1971 01:00:00 GMT;; Path=/; Version=1; Secure; HttpOnly<br>&lt; Vary: Accept-Encoding<br>&lt; X-XSS-Protection: 1; mode=block<br>&lt; X-Frame-Options: SAMEORIGIN<br>&lt; X-Content-Type-Options: nosniff<br>&lt; Content-Security-Policy: script-src &#x27;self&#x27;; object-src &#x27;none&#x27;; frame-ancestors &#x27;self&#x27; https://*.fortimailcloud.com/ https://fortimail.forticloud.com/<br>&lt; Transfer-Encoding: chunked<br>&lt; Content-Type: text/plain<br>&lt;<br><br>&#123;&quot;errorType&quot;: 7,&quot;errorMsg&quot;: &quot;Failed: Access denied&quot;,&quot;reqAction&quot;: 0,&quot;totalRemoteCount&quot;: 0,&quot;collection&quot;: &quot;[]&quot;&#125;<br></code></pre></td></tr></table></figure><p>不幸的是，当尝试在补丁版本和未补丁版本之间进行差异比较时…我们发现这些二进制文件是完全相同的。这意味着漏洞可能存在于共享库中，因此是时候打开这些文件进行深入分析了。</p><h1 id=动手实践><a href=#动手实践 class=headerlink title=动手实践></a>动手实践</h1><p><em>Ghidra导入视图</em></p><p>哦。太糟糕了。一个boost库…这可能意味着是C++…与其在接下来的几个小时内与自己较劲，我们决定通过<a target=_blank rel=noopener href=https://github.com/LaurieWired/GhidraMCP>Ghidra-MCP</a>桥接和Github Copilot向ChatGPT求助。</p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_5.jpg></p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_6.jpg></p><p>在仔细查看了推荐给我们的函数后，我们发现了一个熟悉的字符串：APSCOOKIE。如果您参考我们之前用curl进行的测试，您会注意到其中一个返回的cookie就是这个值。</p><p>如果您稍微玩一下管理网络界面，您会开始看到偶尔对admin.fe端点的请求包含这个APSCOOKIE值，这似乎用于会话管理。</p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_7.jpg></p><p>在解码这个cookie值后，我们得到了：</p><p><code>Era=0&amp;Payload=qCStu1vT3v+Y++5pCCs9M/CxxddCRrC8SHg+9cfRCA42GU7Cf+8p3iBFSl/4vHteSGePZgk7KGMb8kzRR5c2boDUfiiD65jkByiD3DuRCj1NJR7ESpZQIZlOffSxykRbCTp5l3InoU+q6psG+ve+IRDk9za5K0No9T5RNxCwZxM=&amp;AuthHash=kz4cHPsgudYxy4PPp123FUto=&amp;</code></p><p>APSCOOKIE包含以下URL编码字段：</p><ul><li>Era</li><li>Payload</li><li>AuthHash</li></ul><p>这些听起来像是开始grep搜索的好值。</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">$ grep -rl &quot;Era&quot; ./762 | xargs grep -rl &quot;Payload&quot; | xargs grep -rl &quot;AuthHash&quot;<br>rootfs/lib/libhttputil.so<br><br>$ diff 762/rootfs/lib/libhttputil.so 763/rootfs/lib/libhttputil.so<br>Binary files 762/rootfs/lib/libhttputil.so and 763/rootfs/lib/libhttputil.so differ<br></code></pre></td></tr></table></figure><p>鉴于只有一个文件包含这些值，并且在产品补丁版本和易受攻击版本之间存在差异，因此很可能我们找到了罪魁祸首。</p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_8.jpg></p><p>在Ghidra中加载两个版本后，我们可以看到这些字符串都在函数cookieval_unwrap()中被引用。我们决定给大脑放个假，看看我们的人工智能助手能帮我们走多远。</p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_9.jpg></p><p>第一次回答就不错了。让我们继续。</p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_10.jpg></p><p>不幸的是，之后的回答开始变得越来越不可靠，因此我们决定专注于一些传统的手动分析，将ChatGPT的观察结果作为起点。</p><p>浏览函数后，cookieval_unwrap()看起来是专门用于对每个ASPCOOKIE字段进行base64解码并将其写回输入缓冲区的。由于Era应该是一个数字，让我们将重点放在Payload和AuthHash上。我们将浏览函数的补丁和未补丁版本的反编译代码，追踪每个值的引用。</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">----------<br>未补丁：<br>----------<br>size_t input_size;<br>size_t __size;<br>uchar *AuthHash;<br>uchar *Payload;<br>long output_buffer [2];<br>out_00 = (uchar *)malloc(__size);<br><br>iVar2 = __isoc99_sscanf(param_1,&quot;Era=%1d&amp;Payload=%m[^&amp;]&amp;AuthHash=%m[^&amp;]&amp;&quot;,&amp;Era,&amp;Payload, &amp;AuthHash);<br><br>input_size = strlen((char *)AuthHash);<br>__size = strlen((char *)Payload);<br><br><br>iVar3 = EVP_DecodeUpdate(ctx,(uchar *)output_buffer,&amp;output_size,AuthHash,(int)input_size);<br><br>iVar2 = EVP_DecodeUpdate(ctx,out_00,&amp;local_94,Payload,iVar2);<br><br><br>----------<br>补丁：<br>----------<br>size_t input_size;<br>size_t __size;<br>uchar *AuthHash;<br>uchar *Payload;<br>long output_buffer [2];<br>out_00 = (uchar *)malloc(__size);<br><br>iVar2 = __isoc99_sscanf(param_1,&quot;Era=%1d&amp;Payload=%m[^&amp;]&amp;AuthHash=%m[^&amp;]&amp;&quot;,&amp;Era,&amp;Payload, &amp;AuthHash);<br><br>input_size = strlen((char *)AuthHash);<br>__size = strlen((char *)Payload);<br><br>input_size = strlen((char *)AuthHash);<br>if (input_size &lt; 0x1e) &#123;<br><br>iVar3 = EVP_DecodeUpdate(ctx,(uchar *)output_buffer,&amp;output_size,AuthHash,(int)input_size);<br><br>iVar2 = EVP_DecodeUpdate(ctx,out_00,&amp;local_94,Payload,iVar2);<br></code></pre></td></tr></table></figure><p>补丁和未补丁函数之间的关键区别似乎是用户提供的AuthHash值的大小检查。在原始版本中，我们可以看到AuthHash被解码并写入输出缓冲区，而该缓冲区仅足够容纳16字节。在补丁版本中，我们可以看到添加的大小检查限制了用户在此值中可以发送的数据量。基本上，我们现在知道ChatGPT指出的memcpy()并不完全正确，真正的溢出是由于调用EVP_DecodeUpdate()导致的，该调用写入了解码后的AuthHash值分配的边界之外。</p><p>现在我们知道溢出发生在哪里，但能给我们多少控制权呢？让我们看一下从输出缓冲区开始的栈分配：</p><figure class="highlight plaintext"><table><tr><td class=code><pre><code class="hljs plaintext">RSP+0x50 : local_78 (16 bytes)        &lt;- 溢出开始<br>RSP+0x60 : local_68 (4 bytes)         &lt;- 被覆盖<br>RSP+0x70 : local_58 (16 bytes)        &lt;- 被覆盖<br>RSP+0x80 : local_48 (16 bytes)        &lt;- 被覆盖<br>RSP+0x90 : 保存的 RBX                  &lt;- 被覆盖 ---v<br>RSP+0x98 : 保存的 RBP                  &lt;- 被覆盖<br>RSP+0xA0 : 保存的 R12                  &lt;- 被覆盖   这些在<br>RSP+0xA8 : 保存的 R13                  &lt;- 被覆盖   函数序言中保存<br>RSP+0xB0 : 保存的 R14                  &lt;- 被覆盖<br>RSP+0xB8 : 保存的 R15                  &lt;- 被覆盖 ---^<br>RSP+0xC0 : 返回地址 (RIP)              &lt;- 被覆盖<br></code></pre></td></tr></table></figure><p>随着执行的继续，这些栈值保持不变，直到它们再次被memcpy()调用使用。memcpy()的调用恰好使用了我们已经控制的值，这可能在构建有效利用时有用，但目前我们已经控制了将在函数结尾处写入RIP的值，因此无需深入研究。</p><p>让我们开始发送一些垃圾数据，看看会发生什么！由于AuthHash需要是有效的base64，让我们发送一堆正确编码的NULL字符。</p><p><code>AuthHash%3DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%3D%3D</code></p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_11.jpg></p><p>看起来有希望。经过一些循环负载的尝试和错误后，我们能够确定以下内容：</p><p><img src=http://www.18k.icu/images/20250826_05_px0p9w88/img_13.jpg></p><p>💥 鉴于在现代，这种简单的内存破坏问题已经变得非常罕见和过时，能够重温一些上世纪90年代的老式黑客技术是一种不错的改变。</p></div></div><div class=footer id=footer><p>Copyright © 2025 <a class=flink target=_blank rel=noopener href=http://www.18k.icu>www.18k.icu</a> <label class="el-switch el-switch-green el-switch-sm" style=vertical-align:sub><input type=checkbox name=switch id=update_style> <span class=el-switch-style></span></label></p></div><input type=hidden id=web_style value=black> <input type=hidden id=valine_appid value=CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz> <input type=hidden id=valine_appKey value=FqiyUqbg7McKN2eG0MCewupf><script src=https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js></script><script src=/libs/highlight/highlight.pack.js></script><script src=/js/js.js></script><style>.v *{color:#698fca}.v .vlist .vcard .vhead .vsys{color:#3a3e4a}.v .vlist .vcard .vh .vmeta .vat{color:#638fd5}.v .vlist .vcard .vhead .vnick{color:#6ba1ff}.v a{color:#8696b1}.v .vlist .vcard .vhead .vnick:hover{color:#669bfc}</style><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?eb7eb8199824646269cd262b46a87950",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script></body></html>